<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Exemplo Did√°tico - Sync vs. Async</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      background: #f8f9fa;
      padding-top: 20px;
    }
    
    .card {
      box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
      margin-bottom: 20px;
    }
    
    /* BOUNDARIES - dotted boxes to represent process limits */
    .client-process {
      width: 110px;
      height: 320px;
      border: 2px dotted #6c757d;
      border-radius: 8px;
      background: rgba(108, 117, 125, 0.05);
      position: absolute;
      left: 10px;
      top: 25px;
    }
    .client-process-label {
      position: absolute;
      top: 5px;
      left: 20px;
      font-size: 12px;
      font-weight: bold;
      color: #6c757d;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* SERVER PROCESS - middle */
    .server-process {
      width: 160px;
      height: 320px;
      border: 2px dotted #5bc0de;
      border-radius: 8px;
      background: rgba(91, 192, 222, 0.05);
      position: absolute;
      left: 140px;
      top: 25px;
    }
    .server-process-label {
      position: absolute;
      top: 5px;
      left: 180px;
      font-size: 12px;
      font-weight: bold;
      color: #5bc0de;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DATABASE PROCESS - right side */
    .db-process {
      width: 90px;
      height: 120px;
      border: 2px dotted #f0ad4e;
      border-radius: 8px;
      background: rgba(240, 173, 78, 0.05);
      position: absolute;
      left: 320px;
      top: 120px;
    }
    .db-process-label {
      position: absolute;
      top: 100px;
      left: 335px;
      font-size: 12px;
      font-weight: bold;
      color: #f0ad4e;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DIAGRAMA */
    .diagram {
      position: relative;
      width: 100%;
      height: 380px;
      border: 1px dashed #dee2e6;
      overflow: hidden;
      background: #f9f9f9;
      border-radius: 0.25rem;
      margin-bottom: 10px;
    }
    
    /* CLIENTES (3) - quadradinhos √† esquerda */
    .client-box {
      width: 90px; 
      height: 36px;
      background: #cfe2ff;  /* azul claro */
      border: 2px solid #6ea8fe; 
      border-radius: 5px;
      color: #333;
      text-align: center;
      line-height: 36px;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
    }
    .client-box::before {
      content: "üåê";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
    }

    /* THREAD POOL (ret√¢ngulo grande com leve destaque) */
    .thread-pool {
      width: 120px;
      height: 180px;
      border: 2px dashed #5cb85c;
      border-radius: 5px;
      background: #f0fff0;
      position: absolute;
      left: 160px;
      top: 100px;
      z-index: 1;
    }
    .thread-pool-label {
      position: absolute;
      width: 120px;
      text-align: center;
      font-weight: bold;
      color: #5cb85c;
      left: 160px;
      top: 75px;
      font-size: 14px;
      z-index: 2;
    }

    /* THREADS dentro do pool (ret√¢ngulos) */
    .thread-box {
      width: 100px; 
      height: 35px;
      border: 2px solid #5cb85c; 
      background: #e3f9e3;
      border-radius: 5px;
      text-align: center;
      line-height: 35px;
      color: #333;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
    }
    .thread-box::before {
      content: "‚öôÔ∏è";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }
    
    /* Thread bloqueada */
    .thread-blocked {
      background: #ffcccc !important;
      border-color: #dc3545 !important;
      color: #dc3545;
    }
    .thread-blocked::after {
      content: "üîí";
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }

    /* BANCO DE DADOS (ret√¢ngulo/cilindro estilizado) */
    .database {
      width: 60px;
      height: 80px;
      border: 2px solid #f0ad4e;
      border-radius: 5px;
      background: #fdf6ea; /* Amarelinho */
      color: #f0ad4e;
      text-align: center;
      line-height: 80px;
      font-weight: bold;
      position: absolute;
      left: 335px;
      top: 140px;
      z-index: 2;
    }

    /* SETAS (requisi√ß√µes) - vamos usar divs pequenas com texto "=>" para simbolizar setinhas em movimento */
    .arrow {
      position: absolute;
      font-size: 22px;
      font-weight: bold;
      user-select: none;
      pointer-events: none;
      z-index: 3;
      background: rgba(255, 255, 255, 0.7);
      padding: 0 3px;
      border-radius: 3px;
    }
    /* Setas que est√£o "voltando" (vermelho, p.ex.) */
    .arrow.return {
      color: #dc3545;
    }
    
    /* Request ID badge */
    .request-id {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      color: white;
      text-align: center;
      line-height: 18px;
      font-size: 12px;
      font-weight: bold;
      margin-top: -10px;
      margin-left: 15px;
    }

    /* Visual indicator for request in queue */
    .waiting {
      border: 2px dashed #dc3545 !important;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Estado das opera√ß√µes */
    .status-indicator {
      position: absolute;
      bottom: 20px;
      left: 10px;
      right: 10px;
      height: 36px;
      background: rgba(0, 0, 0, 0.07);
      border-radius: 5px;
      text-align: center;
      line-height: 36px;
      font-weight: bold;
      font-size: 14px;
      color: #666;
      z-index: 10;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    /* Contador de requisi√ß√µes */
    .metrics {
      display: flex;
      justify-content: space-around;
      padding: 5px;
      border-top: 1px solid #eee;
    }
    
    /* Temporizador */
    .timer {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      background: rgba(0,0,0,0.1);
      border-radius: 15px;
      font-size: 14px;
      font-weight: bold;
    }
    
    /* Compare indicator */
    .comparison-indicator {
      text-align: center;
      padding: 5px 0;
      font-weight: bold;
      font-size: 0.875rem;
    }
    
    /* Legend row */
    .legend-item {
      display: flex;
      align-items: center;
      margin: 0 10px 10px 0;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border-radius: 3px;
      position: relative;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- Header Section -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <h1 class="text-center mb-3">Fluxo S√≠ncrono vs. Ass√≠ncrono em ASP.NET Core</h1>
          <p class="mb-1"><strong>Cen√°rio:</strong> 2 threads no servidor processando 3 requisi√ß√µes simult√¢neas.</p>
          <p class="mb-2"><strong>S√≠ncrono:</strong> Cada thread fica "presa" aguardando o banco de dados (2s), bloqueando o <em>Thread Pool</em> durante opera√ß√µes I/O.</p>
          <p class="mb-2"><strong>Ass√≠ncrono:</strong> Assim que a requisi√ß√£o inicia I/O no DB (com <code>await</code>), a thread √© devolvida ao <em>Thread Pool</em>.</p>
          <p class="mb-0 text-primary"><strong>Observe:</strong> No modo ass√≠ncrono, todas as requisi√ß√µes s√£o processadas mais rapidamente, mesmo com apenas 2 threads dispon√≠veis!</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Control Section -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body d-flex flex-column align-items-center">
          <div class="d-flex gap-2 mb-2">
            <button id="play-both" class="btn btn-primary">‚ñ∂Ô∏è Iniciar Compara√ß√£o</button>
            <button id="pause-both" class="btn btn-secondary" disabled>‚è∏Ô∏è Pausar</button>
            <button id="reset-both" class="btn btn-outline-secondary">üîÑ Reiniciar</button>
          </div>
          <div class="d-flex gap-4 mt-2">
            <div id="sync-time" class="badge bg-danger">S√≠ncrono: --</div>
            <div id="async-time" class="badge bg-success">Ass√≠ncrono: --</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Diagrams Section -->
  <div class="row">
    <!-- S√≠ncrono -->
    <div class="col-md-6 mb-4">
      <div class="card h-100">
        <div class="card-header bg-danger bg-opacity-25">
          <h5 class="card-title text-center mb-0">S√≠ncrono</h5>
        </div>
        <div class="card-body p-2">
          <div class="diagram" id="sync-diagram">
            <!-- Boundaries -->
            <div class="client-process"></div>
            <div class="client-process-label">Processo Cliente</div>
            
            <div class="server-process"></div>
            <div class="server-process-label">Processo Servidor</div>
            
            <div class="db-process"></div>
            <div class="db-process-label">Banco de Dados</div>
            
            <!-- 3 Clients -->
            <div class="client-box" style="left:20px; top:60px;">Request 1</div>
            <div class="client-box" style="left:20px; top:150px;">Request 2</div>
            <div class="client-box" style="left:20px; top:240px;">Request 3</div>

            <!-- Thread Pool -->
            <div class="thread-pool"></div>
            <div class="thread-pool-label">Thread Pool (2)</div>

            <!-- 2 Threads dentro do pool -->
            <div class="thread-box" style="left:170px; top:120px;">Thread 1</div>
            <div class="thread-box" style="left:170px; top:200px;">Thread 2</div>

            <!-- DB √† direita -->
            <div class="database">DB</div>
            
            <!-- Timer -->
            <div class="timer" id="sync-timer">0.0s</div>
            
            <!-- Status Indicator -->
            <div class="status-indicator">Pronto para iniciar</div>
          </div>
          <div class="d-flex justify-content-around mt-2">
            <div>Requisi√ß√µes: <span id="sync-completed" class="badge bg-primary">0</span>/3</div>
            <div>Threads Bloqueadas: <span id="sync-blocked" class="badge bg-danger">0</span>/2</div>
            <div>Threads Dispon√≠veis: <span id="sync-available" class="badge bg-success">2</span>/2</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Ass√≠ncrono -->
    <div class="col-md-6 mb-4">
      <div class="card h-100">
        <div class="card-header bg-success bg-opacity-25">
          <h5 class="card-title text-center mb-0">Ass√≠ncrono</h5>
        </div>
        <div class="card-body p-2">
          <div class="diagram" id="async-diagram">
            <!-- Boundaries -->
            <div class="client-process"></div>
            <div class="client-process-label">Processo Cliente</div>
            
            <div class="server-process"></div>
            <div class="server-process-label">Processo Servidor</div>
            
            <div class="db-process"></div>
            <div class="db-process-label">Banco de Dados</div>
            
            <!-- 3 Clients -->
            <div class="client-box" style="left:20px; top:50px;">Request 1</div>
            <div class="client-box" style="left:20px; top:130px;">Request 2</div>
            <div class="client-box" style="left:20px; top:210px;">Request 3</div>

            <!-- Thread Pool -->
            <div class="thread-pool"></div>
            <div class="thread-pool-label">Thread Pool (2)</div>

            <!-- 2 Threads dentro do pool -->
            <div class="thread-box" style="left:170px; top:100px;">Thread 1</div>
            <div class="thread-box" style="left:170px; top:180px;">Thread 2</div>

            <!-- DB √† direita -->
            <div class="database">DB</div>
            
            <!-- Timer -->
            <div class="timer" id="async-timer">0.0s</div>
            
            <!-- Status Indicator -->
            <div class="status-indicator">Pronto para iniciar</div>
          </div>
          <div class="d-flex justify-content-around mt-2">
            <div>Requisi√ß√µes: <span id="async-completed" class="badge bg-primary">0</span>/3</div>
            <div>Threads Dispon√≠veis: <span id="async-available" class="badge bg-success">2</span>/2</div>
            <div>Threads Bloqueadas: <span id="async-blocked" class="badge bg-danger">0</span>/2</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Legend -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="d-flex flex-wrap">
            <div class="legend-item">
              <div class="legend-color" style="background: #cfe2ff; border: 2px solid #6ea8fe; position: relative;">
                <span style="position: absolute; left: 1px; top: -1px; font-size: 14px;">üåê</span>
              </div>
              <span>Requisi√ß√£o Web</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #e3f9e3; border: 2px solid #5cb85c; position: relative;">
                <span style="position: absolute; left: 1px; top: -1px; font-size: 12px;">‚öôÔ∏è</span>
              </div>
              <span>Thread Dispon√≠vel</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #ffcccc; border: 2px solid #dc3545; position: relative;">
                <span style="position: absolute; right: 1px; top: -1px; font-size: 12px;">üîí</span>
              </div>
              <span>Thread Bloqueada</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #f0fff0; border: 2px dashed #5cb85c;"></div>
              <span>Thread Pool</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: #fdf6ea; border: 2px solid #f0ad4e;"></div>
              <span>Banco de Dados</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Code comparison -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header">
          <h5 class="card-title mb-0">C√≥digo em ASP.NET Core</h5>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-danger">Abordagem S√≠ncrona</h6>
              <pre><code class="bg-light p-3 d-block">public IEnumerable&lt;Company> GetCompanies()
{
    _logger.LogInfo("Buscando empresas...");
    var companies = _context.Companies.ToList();
    return companies;
}</code></pre>
              <p class="small">O m√©todo s√≠ncrono bloqueia a thread enquanto aguarda o resultado do banco de dados.</p>
            </div>
            <div class="col-md-6">
              <h6 class="text-success">Abordagem Ass√≠ncrona</h6>
              <pre><code class="bg-light p-3 d-block">public async Task&lt;IEnumerable&lt;Company>> GetCompanies()
{
    _logger.LogInfo("Buscando empresas...");
    var companies = await _context.Companies.ToListAsync();
    return companies;
}</code></pre>
              <p class="small">O m√©todo ass√≠ncrono libera a thread ao encontrar o <code>await</code>, devolvendo-a ao pool.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Ativar logs para debug
  const DEBUG = true;
  console.log = DEBUG ? console.log.bind(console) : function(){};

  // Estado global de anima√ß√£o
  const animation = {
    sync: {
      running: false,
      completed: 0,
      blocked: 0,
      available: 2,
      startTime: 0,
      endTime: 0,
      endTimeSet: false,
      intervalId: null,
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: []
    },
    async: {
      running: false,
      completed: 0,
      available: 2,
      blocked: 0,
      startTime: 0,
      endTime: 0,
      endTimeSet: false,
      intervalId: null, 
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: []
    }
  };

  // Selecionar elementos DOM
  const elements = {
    syncDiagram: document.getElementById('sync-diagram'),
    asyncDiagram: document.getElementById('async-diagram'),
    syncCompleted: document.getElementById('sync-completed'),
    asyncCompleted: document.getElementById('async-completed'),
    syncBlocked: document.getElementById('sync-blocked'),
    syncAvailable: document.getElementById('sync-available'),
    asyncBlocked: document.getElementById('async-blocked'),
    asyncAvailable: document.getElementById('async-available'),
    syncTimer: document.getElementById('sync-timer'),
    asyncTimer: document.getElementById('async-timer'),
    syncTime: document.getElementById('sync-time'),
    asyncTime: document.getElementById('async-time'),
    playBoth: document.getElementById('play-both'),
    pauseBoth: document.getElementById('pause-both'),
    resetBoth: document.getElementById('reset-both')
  };

  // Event listeners para os controles centrais
  document.getElementById('play-both').addEventListener('click', startBothAnimations);
  document.getElementById('pause-both').addEventListener('click', pauseBothAnimations);
  document.getElementById('reset-both').addEventListener('click', resetBothAnimations);

  // Fun√ß√£o utilit√°ria para criar uma setinha (requisi√ß√£o)
  function createArrow(diagram, x, y, text, color) {
    const arrow = document.createElement('div');
    arrow.className = 'arrow';
    arrow.textContent = text || '=>';
    arrow.style.left = x + 'px';
    arrow.style.top = y + 'px';
    if (color) arrow.style.color = color;
    diagram.appendChild(arrow);
    return arrow;
  }

  // Move "elem" de (x1, y1) para (x2, y2) em 'duration' ms
  function moveElement(elem, x1, y1, x2, y2, duration, callback, type) {
    if (!elem || !document.body.contains(elem)) return;
    
    const steps = 40;
    let step = 0;
    const interval = duration / steps;
    const dx = (x2 - x1) / steps;
    const dy = (y2 - y1) / steps;

    // Incrementar contador de anima√ß√µes em andamento
    if (type) {
      animation[type].animationsInProgress++;
    }

    // Se estiver pausado, salvar para retomar depois
    if (type && animation[type].isPaused) {
      const pausedAnimation = {
        elem, x1, y1, x2, y2, duration, callback, type,
        currentX: x1, currentY: y1, step: 0
      };
      animation[type].pausedAnimations.push(pausedAnimation);
      return;
    }

    const anim = setInterval(() => {
      // Verificar se o elemento ainda existe
      if (!document.body.contains(elem)) {
        clearInterval(anim);
        if (type) {
          animation[type].animationsInProgress--;
        }
        return;
      }
      
      // Se estiver pausado, interromper
      if (type && animation[type].isPaused) {
        clearInterval(anim);
        const pausedAnimation = {
          elem, x1, y1, x2, y2, duration, callback, type,
          currentX: elem.style.left.replace('px', ''),
          currentY: elem.style.top.replace('px', ''),
          step
        };
        animation[type].pausedAnimations.push(pausedAnimation);
        return;
      }

      step++;
      const nx = x1 + dx * step;
      const ny = y1 + dy * step;
      elem.style.left = nx + 'px';
      elem.style.top = ny + 'px';
      if (step >= steps) {
        clearInterval(anim);
        // Decrementar contador de anima√ß√µes em andamento
        if (type) {
          animation[type].animationsInProgress--;
        }
        if (callback) callback();
      }
    }, interval);
  }

  // Limpa as setas antigas e reseta o estado
  function clearArrows(diagram) {
    if (!diagram) return;
    
    // Remover setas
    const oldArrows = diagram.querySelectorAll('.arrow');
    oldArrows.forEach(a => a.remove());
    
    // Reset any waiting indicators
    const clients = diagram.querySelectorAll('.client-box');
    clients.forEach(c => c.classList.remove('waiting'));
    
    // Reset thread status
    const threads = diagram.querySelectorAll('.thread-box');
    threads.forEach(t => t.classList.remove('thread-blocked'));
  }
  
  // Helper to get thread positions
  function getThreadPosition(diagram, threadNumber) {
    if (!diagram) return null;
    
    const threads = diagram.querySelectorAll('.thread-box');
    if (threadNumber <= threads.length) {
      const thread = threads[threadNumber - 1];
      const rect = thread.getBoundingClientRect();
      const diagramRect = diagram.getBoundingClientRect();
      return {
        x: parseInt(thread.style.left) || (rect.left - diagramRect.left + 10),
        y: parseInt(thread.style.top) || (rect.top - diagramRect.top + 15)
      };
    }
    return null;
  }

  // Atualizar contadores
  function updateCounters(type) {
    if (type === 'sync') {
      elements.syncCompleted.textContent = animation.sync.completed;
      elements.syncBlocked.textContent = animation.sync.blocked;
      elements.syncAvailable.textContent = animation.sync.available;
    } else {
      elements.asyncCompleted.textContent = animation.async.completed;
      elements.asyncAvailable.textContent = animation.async.available;
      elements.asyncBlocked.textContent = animation.async.blocked;
    }
  }

  // Atualizar timer
  function updateTimer(type) {
    if (!animation[type].running) return;
    
    const elapsed = (Date.now() - animation[type].startTime) / 1000;
    const timer = document.getElementById(`${type}-timer`);
    timer.textContent = `${elapsed.toFixed(1)}s`;
    
    // Log para debug
    if (DEBUG && elapsed % 2 < 0.1) {
      console.log(`[${type.toUpperCase()}] Elapsed: ${elapsed.toFixed(1)}s, Completed: ${animation[type].completed}/3`);
    }
    
    // Se todas as requisi√ß√µes conclu√≠das e n√£o h√° mais anima√ß√µes em andamento, registrar tempo e reiniciar
    if (animation[type].completed === 3 && animation[type].animationsInProgress === 0 && !animation[type].endTimeSet) {
      // Marcar que j√° registramos o tempo final para evitar m√∫ltiplas chamadas
      animation[type].endTimeSet = true;
      animation[type].endTime = Date.now();
      const totalTime = ((animation[type].endTime - animation[type].startTime) / 1000).toFixed(1);
      document.getElementById(`${type}-time`).textContent = `${type === 'sync' ? 'S√≠ncrono' : 'Ass√≠ncrono'}: ${totalTime}s`;
      
      // Log de conclus√£o
      console.log(`[${type.toUpperCase()}] All requests completed in ${totalTime}s`);
      
      // Destacar a mensagem de conclus√£o
      const statusIndicator = document.querySelector(`#${type}-diagram .status-indicator`);
      if (statusIndicator) {
        statusIndicator.textContent = 'Todas as requisi√ß√µes processadas';
        statusIndicator.style.fontWeight = 'bold';
        statusIndicator.style.color = '#007bff';
        statusIndicator.style.fontSize = '16px';
        statusIndicator.style.backgroundColor = 'rgba(232, 244, 255, 0.8)';
        statusIndicator.style.border = '1px solid #b8daff';
      }
      
      // Reiniciar automaticamente ap√≥s pequena pausa
      setTimeout(() => {
        if (!animation[type].isPaused) {
          resetAnimation(type);
          startAnimation(type);
        }
      }, 5000); // Tempo maior para visualizar o estado final
    }
  }

  // Iniciar anima√ß√£o
  function startAnimation(type) {
    if (animation[type].running && !animation[type].isPaused) return;
    
    // Se estiver pausado, resumir
    if (animation[type].isPaused) {
      resumeAnimation(type);
      return;
    }
    
    // Resetar primeiro
    resetAnimation(type);
    
    // Configurar estado
    animation[type].running = true;
    animation[type].startTime = Date.now();
    animation[type].intervalId = setInterval(() => updateTimer(type), 100);
    
    console.log(`[${type.toUpperCase()}] Starting animation`);
    
    // Iniciar fluxo apropriado
    if (type === 'sync') {
      startSync();
    } else {
      startAsync();
    }
  }
  
  // Pausar anima√ß√£o
  function pauseAnimation(type) {
    if (!animation[type].running) return;
    animation[type].isPaused = true;
    console.log(`[${type.toUpperCase()}] Animation paused`);
  }
  
  // Pausar ambas anima√ß√µes
  function pauseBothAnimations() {
    pauseAnimation('sync');
    pauseAnimation('async');
    elements.pauseBoth.disabled = true;
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Continuar';
  }
  
  // Resumir anima√ß√£o
  function resumeAnimation(type) {
    if (!animation[type].running || !animation[type].isPaused) return;
    
    animation[type].isPaused = false;
    console.log(`[${type.toUpperCase()}] Animation resumed`);
    
    // Retomar anima√ß√µes pausadas
    const pausedAnimations = animation[type].pausedAnimations;
    while (pausedAnimations.length > 0) {
      const anim = pausedAnimations.pop();
      moveElement(
        anim.elem, 
        parseFloat(anim.currentX), 
        parseFloat(anim.currentY), 
        anim.x2, 
        anim.y2, 
        anim.duration * (1 - anim.step / 40), 
        anim.callback,
        anim.type
      );
    }
  }
  
  // Resetar anima√ß√£o
  function resetAnimation(type) {
    console.log(`[${type.toUpperCase()}] Resetting animation`);
    
    // Parar qualquer anima√ß√£o em andamento
    clearInterval(animation[type].intervalId);
    
    // Limpar setas
    clearArrows(document.getElementById(`${type}-diagram`));
    
    // Resetar estado
    animation[type].running = false;
    animation[type].completed = 0;
    animation[type].animationsInProgress = 0;
    animation[type].isPaused = false;
    animation[type].pausedAnimations = [];
    animation[type].endTimeSet = false;
    
    if (type === 'sync') {
      animation.sync.blocked = 0;
      animation.sync.available = 2;
    } else {
      animation.async.blocked = 0;
      animation.async.available = 2;
    }
    
    // Atualizar contadores
    updateCounters(type);
    
    // Resetar timer
    document.getElementById(`${type}-timer`).textContent = '0.0s';
    
    // Resetar status
    const statusIndicator = document.querySelector(`#${type}-diagram .status-indicator`);
    if (statusIndicator) {
      statusIndicator.textContent = 'Pronto para iniciar';
      statusIndicator.style.fontWeight = '';
      statusIndicator.style.color = '';
      statusIndicator.style.fontSize = '';
      statusIndicator.style.backgroundColor = '';
      statusIndicator.style.border = '';
    }
  }
  
  // Iniciar ambas anima√ß√µes
  function startBothAnimations() {
    if (animation.sync.isPaused || animation.async.isPaused) {
      // Se estiver pausado, continuar
      resumeAnimation('sync');
      resumeAnimation('async');
      elements.playBoth.disabled = true;
      elements.pauseBoth.disabled = false;
      return;
    }
    
    startAnimation('sync');
    startAnimation('async');
    
    elements.playBoth.disabled = true;
    elements.pauseBoth.disabled = false;
  }
  
  // Resetar ambas anima√ß√µes
  function resetBothAnimations() {
    resetAnimation('sync');
    resetAnimation('async');
    elements.syncTime.textContent = 'S√≠ncrono: --';
    elements.asyncTime.textContent = 'Ass√≠ncrono: --';
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Iniciar Compara√ß√£o';
    elements.pauseBoth.disabled = true;
  }

  /* ======================================
       FLUXO S√çNCRONO
     ====================================== */
  function startSync() {
    const diagram = elements.syncDiagram;
    clearArrows(diagram);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    statusIndicator.textContent = 'Iniciando requisi√ß√µes s√≠ncronas...';

    // Posi√ß√µes iniciais das setinhas (3 clientes)
    const requests = [
      { x: 50, y: 75, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 165, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 255, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    // Free threads pool - usando um objeto para manter consist√™ncia entre chamadas
    const threadPoolRef = { pool: [1, 2] };
    
    // Start requests with slight delays
    if (!animation.sync.isPaused) {
      setTimeout(() => startRequest(0), 200);
      setTimeout(() => {
        if (!animation.sync.isPaused) startRequest(1);
      }, 800);
      setTimeout(() => {
        if (!animation.sync.isPaused) startRequest(2);
      }, 1400);
    }
    
    function startRequest(index) {
      if (!animation.sync.running) return;
      
      const request = requests[index];
      
      // Create arrow with id badge
      const arrow = createArrow(diagram, request.x, request.y, '=>', request.color);
      const requestBadge = document.createElement('div');
      requestBadge.className = 'request-id';
      requestBadge.style.backgroundColor = request.color;
      requestBadge.textContent = request.id;
      arrow.appendChild(requestBadge);
      
      console.log(`[SYNC] Request ${request.id} started, available threads: ${threadPoolRef.pool.length}`);
      
      // Check if a thread is available
      if (threadPoolRef.pool.length > 0) {
        // Get a thread from the pool
        const threadNumber = threadPoolRef.pool.shift();
        
        // Atualizar contadores
        animation.sync.blocked++;
        animation.sync.available = threadPoolRef.pool.length;
        updateCounters('sync');
        
        const threadPos = getThreadPosition(diagram, threadNumber);
        
        // Get the thread element
        const threadElements = diagram.querySelectorAll('.thread-box');
        const threadElem = threadElements[threadNumber - 1];
        
        // Client -> Thread
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
        moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
          if (!animation.sync.running) return;
          
          // Thread processing - mark thread as assigned
          statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id}`;
          
          // Thread -> DB (Thread is blocked during this operation)
          if (threadElem && document.body.contains(threadElem)) {
            threadElem.classList.add('thread-blocked'); // Mark thread as blocked
          }
          
          moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
            if (!animation.sync.running) return;
            
            // "Bloqueado" por 2s no DB
            statusIndicator.textContent = `Thread ${threadNumber} BLOQUEADA aguardando DB (SYNC, bloqueia thread)`;
            
            // Timeout para simular opera√ß√£o de I/O
            setTimeout(() => {
              if (!animation.sync.running) return;
              
              // Return DB -> Thread
              statusIndicator.textContent = `Banco de dados respondeu para requisi√ß√£o ${request.id}`;
              if (arrow && document.body.contains(arrow)) {
                arrow.classList.add('return');
                moveElement(arrow, 350, threadPos.y, threadPos.x, threadPos.y, 700, () => {
                  if (!animation.sync.running) return;
                  
                  // Thread -> Client
                  statusIndicator.textContent = `Thread ${threadNumber} enviando resposta ao cliente (req. ${request.id})`;
                  moveElement(arrow, threadPos.x, threadPos.y, request.x, request.y, 700, () => {
                    if (!animation.sync.running) return;
                    
                    // Return thread to the pool
                    if (threadElem && document.body.contains(threadElem)) {
                      threadElem.classList.remove('thread-blocked'); // Unblock thread
                    }
                    threadPoolRef.pool.push(threadNumber);
                    
                    // Atualizar contadores
                    animation.sync.blocked--;
                    animation.sync.completed++;
                    animation.sync.available = threadPoolRef.pool.length;
                    updateCounters('sync');
                    
                    console.log(`[SYNC] Request ${request.id} completed, threads returned to pool: ${threadPoolRef.pool.length}`);
                    
                    statusIndicator.textContent = `Thread ${threadNumber} liberada, voltou para o pool`;
                    
                    // Check if there are waiting clients and process them
                    const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                    if (waitingClients.length > 0) {
                      waitingClients[0].classList.remove('waiting');
                      const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                      const waitingIndex = requests.findIndex(r => r.id === waitingId);
                      
                      console.log(`[SYNC] Starting waiting request ${waitingId}`);
                      
                      // Start waiting request after a small delay
                      setTimeout(() => startRequest(waitingIndex), 300);
                    }
                  }, 'sync');
                }, 'sync');
              }
            }, animation.sync.isPaused ? 0 : 2000);
          }, 'sync');
        }, 'sync');
      } else {
        // No thread available, make the client "wait"
        const clients = diagram.querySelectorAll('.client-box');
        clients[request.clientIndex].classList.add('waiting');
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel (pool esgotado)`;
        console.log(`[SYNC] Request ${request.id} waiting for thread, no threads available`);
      }
    }
  }

  /* ======================================
       FLUXO ASS√çNCRONO
     ====================================== */
  function startAsync() {
    const diagram = elements.asyncDiagram;
    clearArrows(diagram);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    statusIndicator.textContent = 'Iniciando requisi√ß√µes ass√≠ncronas...';

    const requests = [
      { x: 50, y: 65, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 145, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 225, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    // Free threads pool - usando um objeto para manter consist√™ncia entre chamadas
    const threadPoolRef = { pool: [1, 2] };
    
    // Track pending I/O operations for visualization
    const pendingDbOperationsRef = { operations: [] };
    
    // Start requests with slight delays - same timing as sync for comparison
    if (!animation.async.isPaused) {
      setTimeout(() => startRequest(0), 200);
      setTimeout(() => {
        if (!animation.async.isPaused) startRequest(1);
      }, 800);
      setTimeout(() => {
        if (!animation.async.isPaused) startRequest(2);
      }, 1400);
    }
    
    function startRequest(index) {
      if (!animation.async.running) return;
      
      const request = requests[index];
      
      // Create arrow with id badge
      const arrow = createArrow(diagram, request.x, request.y, '=>', request.color);
      const requestBadge = document.createElement('div');
      requestBadge.className = 'request-id';
      requestBadge.style.backgroundColor = request.color;
      requestBadge.textContent = request.id;
      arrow.appendChild(requestBadge);
      
      console.log(`[ASYNC] Request ${request.id} started, available threads: ${threadPoolRef.pool.length}`);
      
      // Check if a thread is available
      if (threadPoolRef.pool.length > 0) {
        // Get a thread from the pool
        const threadNumber = threadPoolRef.pool.shift();
        
        // Atualizar contadores
        animation.async.blocked++;
        animation.async.available = threadPoolRef.pool.length;
        updateCounters('async');
        
        const threadPos = getThreadPosition(diagram, threadNumber);
        
        // Get the thread element
        const threadElements = diagram.querySelectorAll('.thread-box');
        const threadElem = threadElements[threadNumber - 1];
        
        // Client -> Thread
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
        moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
          if (!animation.async.running) return;
          
          // Thread processing - brief CPU work
          statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id} (setup)`;
          
          // Quick thread work (async setup)
          setTimeout(() => {
            if (!animation.async.running) return;
            
            // *** Thread is released here (await) - KEY DIFFERENCE ***
            statusIndicator.textContent = `Thread ${threadNumber} encontrou await, RETORNANDO AO POOL (ASYNC)`;
            
            // Return thread to the pool immediately
            threadPoolRef.pool.push(threadNumber);
            
            // Atualizar contadores
            animation.async.blocked--;
            animation.async.available = threadPoolRef.pool.length;
            updateCounters('async');
            
            console.log(`[ASYNC] Thread ${threadNumber} returned to pool at await, now available: ${threadPoolRef.pool.length}`);
            
            // Check if there are waiting clients and process them
            const waitingClients = diagram.querySelectorAll('.client-box.waiting');
            if (waitingClients.length > 0) {
              waitingClients[0].classList.remove('waiting');
              const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
              const waitingIndex = requests.findIndex(r => r.id === waitingId);
              
              statusIndicator.textContent = `Thread ${threadNumber} dispon√≠vel para requisi√ß√£o ${waitingId}`;
              console.log(`[ASYNC] Starting waiting request ${waitingId} with newly available thread`);
              
              // Start waiting request after a small delay
              setTimeout(() => startRequest(waitingIndex), 300);
            }
            
            // Arrow continues to DB without blocking thread
            statusIndicator.textContent = `Requisi√ß√£o ${request.id} continua para o DB (sem thread bloqueado)`;
            moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
              if (!animation.async.running) return;
              
              // Add to pending DB operations
              pendingDbOperationsRef.operations.push(request.id);
              
              // I/O operation in DB
              statusIndicator.textContent = `Requisi√ß√£o ${request.id} executando no banco de dados (I/O ass√≠ncrono)`;
              
              // Timeout para simular opera√ß√£o de I/O - same time as sync for comparison
              setTimeout(() => {
                if (!animation.async.running) return;
                
                // Remove from pending operations
                pendingDbOperationsRef.operations = pendingDbOperationsRef.operations.filter(id => id !== request.id);
                
                // Get thread for completion (might be different thread)
                if (threadPoolRef.pool.length === 0) {
                  statusIndicator.textContent = `Requisi√ß√£o ${request.id} aguardando thread dispon√≠vel (opera√ß√£o I/O completou)`;
                  
                  // We'll check periodically if a thread becomes available
                  const checkInterval = setInterval(() => {
                    if (!animation.async.running) {
                      clearInterval(checkInterval);
                      return;
                    }
                    
                    if (threadPoolRef.pool.length > 0) {
                      clearInterval(checkInterval);
                      continueAfterDb();
                    }
                  }, 300);
                } else {
                  continueAfterDb();
                }
                
                function continueAfterDb() {
                  if (!animation.async.running) return;
                  
                  const returnThreadNumber = threadPoolRef.pool.shift();
                  
                  // Atualizar contadores
                  animation.async.blocked++;
                  animation.async.available = threadPoolRef.pool.length;
                  updateCounters('async');
                  
                  const returnThreadPos = getThreadPosition(diagram, returnThreadNumber);
                  const returnThreadElements = diagram.querySelectorAll('.thread-box');
                  const returnThreadElem = returnThreadElements[returnThreadNumber - 1];
                  
                  // Response DB -> Thread
                  statusIndicator.textContent = `Banco respondeu! Req. ${request.id} obt√©m Thread ${returnThreadNumber} (pode ser diferente)`;
                  
                  if (arrow && document.body.contains(arrow)) {
                    arrow.classList.add('return');
                    moveElement(arrow, 350, threadPos.y, returnThreadPos.x, returnThreadPos.y, 700, () => {
                      if (!animation.async.running) return;
                      
                      // Quick completion work
                      statusIndicator.textContent = `Thread ${returnThreadNumber} finalizando requisi√ß√£o ${request.id} (p√≥s-await)`;
                      
                      setTimeout(() => {
                        if (!animation.async.running) return;
                        
                        // Thread -> Client
                        statusIndicator.textContent = `Thread ${returnThreadNumber} enviando resposta (req. ${request.id})`;
                        
                        moveElement(arrow, returnThreadPos.x, returnThreadPos.y, request.x, request.y, 700, () => {
                          if (!animation.async.running) return;
                          
                          // Return thread to pool
                          threadPoolRef.pool.push(returnThreadNumber);
                          
                          // Atualizar contadores
                          animation.async.blocked--;
                          animation.async.completed++;
                          animation.async.available = threadPoolRef.pool.length;
                          updateCounters('async');
                          
                          console.log(`[ASYNC] Request ${request.id} completed, thread ${returnThreadNumber} returned to pool, available: ${threadPoolRef.pool.length}`);
                          
                          statusIndicator.textContent = `Thread ${returnThreadNumber} liberada, voltou para o pool`;
                          
                          // Check again for waiting clients
                          const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                          if (waitingClients.length > 0) {
                            waitingClients[0].classList.remove('waiting');
                            const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                            const waitingIndex = requests.findIndex(r => r.id === waitingId);
                            
                            console.log(`[ASYNC] Starting waiting request ${waitingId}`);
                            
                            // Start waiting request after a small delay
                            setTimeout(() => startRequest(waitingIndex), 300);
                          }
                        }, 'async');
                      }, animation.async.isPaused ? 0 : 300);
                    }, 'async');
                  }
                }
              }, animation.async.isPaused ? 0 : 2000);
            }, 'async');
          }, animation.async.isPaused ? 0 : 500);
        }, 'async');
      } else {
        // No thread available, make the client "wait"
        const clients = diagram.querySelectorAll('.client-box');
        clients[request.clientIndex].classList.add('waiting');
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel (pool esgotado)`;
        console.log(`[ASYNC] Request ${request.id} waiting, no threads available`);
      }
    }
  }
</script>

</body>
</html>
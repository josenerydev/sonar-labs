<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Exemplo Did√°tico - Sync vs. Async</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      background: #f8f9fa;
      padding-top: 20px;
    }
    
    .card {
      box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
      margin-bottom: 20px;
    }
    
    /* Event Log Styles */
    .event-log {
      position: absolute;
      top: 50px;
      width: 210px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 0;
      z-index: 10;
      max-height: 250px;
      overflow-y: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Event List Styles */
    .event-list-card {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .event-list-card li {
      font-size: 12px;
      padding: 6px 10px;
      border-bottom: 1px solid #eee;
      color: #333;
    }
    
    .event-list-card li:nth-child(odd) {
      background-color: #f9f9f9;
    }
    
    .event-list-card li.event-request { color: #0275d8; }
    .event-list-card li.event-thread { color: #5cb85c; }
    .event-list-card li.event-db { color: #f0ad4e; }
    .event-list-card li.event-complete { color: #5bc0de; }
    .event-list-card li.event-wait { color: #d9534f; }
    
    /* BOUNDARIES - dotted boxes to represent process limits */
    .client-process {
      width: 110px;
      height: 320px;
      border: 2px dotted #6c757d;
      border-radius: 8px;
      background: rgba(108, 117, 125, 0.05);
      position: absolute;
      left: 10px;
      top: 25px;
    }
    .client-process-label {
      position: absolute;
      top: 5px;
      left: 20px;
      font-size: 12px;
      font-weight: bold;
      color: #6c757d;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* SERVER PROCESS - middle */
    .server-process {
      width: 160px;
      height: 320px;
      border: 2px dotted #5bc0de;
      border-radius: 8px;
      background: rgba(91, 192, 222, 0.05);
      position: absolute;
      left: 140px;
      top: 25px;
    }
    .server-process-label {
      position: absolute;
      top: 5px;
      left: 180px;
      font-size: 12px;
      font-weight: bold;
      color: #5bc0de;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DATABASE PROCESS - right side */
    .db-process {
      width: 90px;
      height: 120px;
      border: 2px dotted #f0ad4e;
      border-radius: 8px;
      background: rgba(240, 173, 78, 0.05);
      position: absolute;
      left: 320px;
      top: 120px;
    }
    .db-process-label {
      position: absolute;
      top: 100px;
      left: 335px;
      font-size: 12px;
      font-weight: bold;
      color: #f0ad4e;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DIAGRAMA */
    .diagram {
      position: relative;
      width: 100%;
      height: 380px;
      border: 1px dashed #dee2e6;
      overflow: hidden;
      background: #f9f9f9;
      border-radius: 0.25rem;
      margin-bottom: 10px;
    }
    
    /* CLIENTES (3) - quadradinhos √† esquerda */
    .client-box {
      width: 90px; 
      height: 36px;
      background: #cfe2ff;  /* azul claro */
      border: 2px solid #6ea8fe; 
      border-radius: 5px;
      color: #333;
      text-align: center;
      line-height: 36px;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
      padding-left: 16px; /* Espa√ßo para o √≠cone */
    }
    .client-box::before {
      content: "üåê";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
    }

    /* THREAD POOL (ret√¢ngulo grande com leve destaque) */
    .thread-pool {
      width: 120px;
      height: 180px;
      border: 2px dashed #5cb85c;
      border-radius: 5px;
      background: #f0fff0;
      position: absolute;
      left: 160px;
      top: 100px;
      z-index: 1;
    }
    .thread-pool-label {
      position: absolute;
      width: 120px;
      text-align: center;
      font-weight: bold;
      color: #5cb85c;
      left: 160px;
      top: 75px;
      font-size: 14px;
      z-index: 2;
    }

    /* THREADS dentro do pool (ret√¢ngulos) */
    .thread-box {
      width: 100px; 
      height: 35px;
      border: 2px solid #5cb85c; 
      background: #e3f9e3;
      border-radius: 5px;
      text-align: center;
      line-height: 35px;
      color: #333;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
      padding-left: 16px; /* Espa√ßo para o √≠cone */
    }
    .thread-box::before {
      content: "‚öôÔ∏è";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }
    
    /* Thread bloqueada */
    .thread-blocked {
      background: #ffcccc !important;
      border-color: #dc3545 !important;
      color: #dc3545;
    }
    .thread-blocked::after {
      content: "üîí";
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }

    /* BANCO DE DADOS (ret√¢ngulo/cilindro estilizado) */
    .database {
      width: 60px;
      height: 80px;
      border: 2px solid #f0ad4e;
      border-radius: 5px;
      background: #fdf6ea; /* Amarelinho */
      color: #f0ad4e;
      text-align: center;
      line-height: 80px;
      font-weight: bold;
      position: absolute;
      left: 335px;
      top: 140px;
      z-index: 2;
    }

    /* SETAS (requisi√ß√µes) - vamos usar divs pequenas com texto "=>" para simbolizar setinhas em movimento */
    .arrow {
      position: absolute;
      font-size: 22px;
      font-weight: bold;
      user-select: none;
      pointer-events: none;
      z-index: 3;
      background: rgba(255, 255, 255, 0.7);
      padding: 0 3px;
      border-radius: 3px;
    }
    /* Setas que est√£o "voltando" (vermelho, p.ex.) */
    .arrow.return {
      color: #dc3545;
    }
    
    /* Request ID badge */
    .request-id {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      color: white;
      text-align: center;
      line-height: 18px;
      font-size: 12px;
      font-weight: bold;
      margin-top: -10px;
      margin-left: 15px;
    }

    /* Visual indicator for request in queue */
    .waiting {
      border: 2px dashed #dc3545 !important;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Estado das opera√ß√µes */
    .status-indicator {
      position: absolute;
      bottom: 20px;
      left: 10px;
      right: 10px;
      height: 36px;
      background: rgba(0, 0, 0, 0.07);
      border-radius: 5px;
      text-align: center;
      line-height: 36px;
      font-weight: bold;
      font-size: 14px;
      color: #666;
      z-index: 10;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    /* Contador de requisi√ß√µes */
    .metrics {
      display: flex;
      justify-content: space-around;
      padding: 5px;
      border-top: 1px solid #eee;
    }
    
    /* Compare indicator */
    .comparison-indicator {
      text-align: center;
      padding: 5px 0;
      font-weight: bold;
      font-size: 0.875rem;
    }
    
    /* Legend row */
    .legend-item {
      display: flex;
      align-items: center;
      margin: 0 15px 10px 0;
    }
    
    .legend-color {
      width: 24px;
      height: 24px;
      margin-right: 8px;
      border-radius: 3px;
      position: relative;
    }

    /* Melhoria de responsividade */
    @media (max-width: 768px) {
      .diagram {
        height: 450px;
      }
      
      .event-list-card {
        max-height: 150px;
      }
      
      .client-process, .server-process, .db-process {
        transform: scale(0.9);
        transform-origin: center;
      }
    }

    /* Melhor centraliza√ß√£o */
    .metrics-row {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 10px;
    }
    
    .metrics-item {
      text-align: center;
      padding: 5px 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .badge {
      font-size: 14px;
      font-weight: 600;
      padding: 4px 8px;
      background-color: #6c757d;
    }
    
    .controls-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    
    .btn {
      min-width: 120px;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- Header Section -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <h1 class="text-center mb-3">Fluxo S√≠ncrono vs. Ass√≠ncrono em ASP.NET Core</h1>
          <p class="mb-1"><strong>Cen√°rio:</strong> 2 threads no servidor processando 3 requisi√ß√µes simult√¢neas.</p>
          <p class="mb-2"><strong>S√≠ncrono:</strong> Cada thread fica "presa" aguardando o banco de dados (2s), bloqueando o <em>Thread Pool</em> durante opera√ß√µes I/O.</p>
          <p class="mb-2"><strong>Ass√≠ncrono:</strong> Assim que a requisi√ß√£o inicia I/O no DB (com <code>await</code>), a thread √© devolvida ao <em>Thread Pool</em>.</p>
          <p class="mb-0 text-primary"><strong>Observe:</strong> No modo ass√≠ncrono, todas as requisi√ß√µes s√£o processadas mais rapidamente, mesmo com apenas 2 threads dispon√≠veis!</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Control Section -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="controls-container">
            <button id="play-both" class="btn btn-primary">‚ñ∂Ô∏è Iniciar Compara√ß√£o</button>
            <button id="pause-both" class="btn btn-secondary" disabled>‚è∏Ô∏è Pausar</button>
            <button id="reset-both" class="btn btn-outline-secondary">üîÑ Reiniciar</button>
          </div>
          <div class="mt-3 text-center">
            <div id="global-timer" class="badge bg-dark p-2 fs-6">Tempo: 0s</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Diagrams Section -->
  <div class="row">
    <!-- S√≠ncrono -->
    <div class="col-md-6 mb-4">
      <div class="card h-100">
        <div class="card-header bg-danger bg-opacity-25">
          <h5 class="card-title text-center mb-0">S√≠ncrono</h5>
        </div>
        <div class="card-body p-2">
          <div class="diagram" id="sync-diagram">
            <!-- Boundaries -->
            <div class="client-process"></div>
            <div class="client-process-label">Processo Cliente</div>
            
            <div class="server-process"></div>
            <div class="server-process-label">Processo Servidor</div>
            
            <div class="db-process"></div>
            <div class="db-process-label">Banco de Dados</div>
            
            <!-- 3 Clients -->
            <div class="client-box" style="left:20px; top:60px;">Request 1</div>
            <div class="client-box" style="left:20px; top:150px;">Request 2</div>
            <div class="client-box" style="left:20px; top:240px;">Request 3</div>

            <!-- Thread Pool -->
            <div class="thread-pool"></div>
            <div class="thread-pool-label">Thread Pool (2)</div>

            <!-- 2 Threads dentro do pool -->
            <div class="thread-box" style="left:170px; top:120px;">Thread 1</div>
            <div class="thread-box" style="left:170px; top:200px;">Thread 2</div>

            <!-- DB √† direita -->
            <div class="database">DB</div>
            
            <!-- Status Indicator -->
            <div class="status-indicator">Pronto para iniciar</div>
          </div>
          <div class="d-flex justify-content-center mt-2">
            <div>Requisi√ß√µes Completas: <span id="sync-completed" class="badge">0</span></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Ass√≠ncrono -->
    <div class="col-md-6 mb-4">
      <div class="card h-100">
        <div class="card-header bg-success bg-opacity-25">
          <h5 class="card-title text-center mb-0">Ass√≠ncrono</h5>
        </div>
        <div class="card-body p-2">
          <div class="diagram" id="async-diagram">
            <!-- Boundaries -->
            <div class="client-process"></div>
            <div class="client-process-label">Processo Cliente</div>
            
            <div class="server-process"></div>
            <div class="server-process-label">Processo Servidor</div>
            
            <div class="db-process"></div>
            <div class="db-process-label">Banco de Dados</div>
            
            <!-- 3 Clients -->
            <div class="client-box" style="left:20px; top:50px;">Request 1</div>
            <div class="client-box" style="left:20px; top:130px;">Request 2</div>
            <div class="client-box" style="left:20px; top:210px;">Request 3</div>

            <!-- Thread Pool -->
            <div class="thread-pool"></div>
            <div class="thread-pool-label">Thread Pool (2)</div>

            <!-- 2 Threads dentro do pool -->
            <div class="thread-box" style="left:170px; top:100px;">Thread 1</div>
            <div class="thread-box" style="left:170px; top:180px;">Thread 2</div>

            <!-- DB √† direita -->
            <div class="database">DB</div>
            
            <!-- Status Indicator -->
            <div class="status-indicator">Pronto para iniciar</div>
          </div>
          <div class="d-flex justify-content-center mt-2">
            <div>Requisi√ß√µes Completas: <span id="async-completed" class="badge">0</span></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Event Logs Section -->
  <div class="row">
    <!-- Sync Events -->
    <div class="col-md-6 mb-4">
      <div class="card">
        <div class="card-header bg-danger bg-opacity-25">
          <h6 class="card-title mb-0">Eventos S√≠ncronos</h6>
        </div>
        <div class="card-body p-2">
          <ul id="sync-events" class="event-list-card"></ul>
        </div>
      </div>
    </div>
    
    <!-- Async Events -->
    <div class="col-md-6 mb-4">
      <div class="card">
        <div class="card-header bg-success bg-opacity-25">
          <h6 class="card-title mb-0">Eventos Ass√≠ncronos</h6>
        </div>
        <div class="card-body p-2">
          <ul id="async-events" class="event-list-card"></ul>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Legend -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="d-flex flex-wrap justify-content-center">
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #cfe2ff; border: 2px solid #6ea8fe; position: relative;">
                <span style="font-size: 14px;">üåê</span>
              </div>
              <span>Requisi√ß√£o Web</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #e3f9e3; border: 2px solid #5cb85c; position: relative;">
                <span style="font-size: 12px;">‚öôÔ∏è</span>
              </div>
              <span>Thread Dispon√≠vel</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #ffcccc; border: 2px solid #dc3545; position: relative;">
                <span style="font-size: 12px;">üîí</span>
              </div>
              <span>Thread Bloqueada</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #f0fff0; border: 2px dashed #5cb85c;"></div>
              <span>Thread Pool</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #fdf6ea; border: 2px solid #f0ad4e;"></div>
              <span>Banco de Dados</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Code comparison -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header">
          <h5 class="card-title mb-0">C√≥digo em ASP.NET Core</h5>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-danger">Abordagem S√≠ncrona</h6>
              <pre><code class="bg-light p-3 d-block">public IEnumerable&lt;Company> GetCompanies()
{
    _logger.LogInfo("Buscando empresas...");
    var companies = _context.Companies.ToList();
    return companies;
}</code></pre>
              <p class="small">O m√©todo s√≠ncrono bloqueia a thread enquanto aguarda o resultado do banco de dados.</p>
            </div>
            <div class="col-md-6">
              <h6 class="text-success">Abordagem Ass√≠ncrona</h6>
              <pre><code class="bg-light p-3 d-block">public async Task&lt;IEnumerable&lt;Company>> GetCompanies()
{
    _logger.LogInfo("Buscando empresas...");
    var companies = await _context.Companies.ToListAsync();
    return companies;
}</code></pre>
              <p class="small">O m√©todo ass√≠ncrono libera a thread ao encontrar o <code>await</code>, devolvendo-a ao pool.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Ativar logs para debug
  const DEBUG = true;
  console.log = DEBUG ? console.log.bind(console) : function(){};
  
  // CORRE√á√ÉO: Timer para garantir novos ciclos automaticamente
  setInterval(function() {
    if (animation.sync.running && !animation.sync.isPaused) {
      if (animation.sync.activeRequests === 0 && animation.sync.animationsInProgress === 0) {
        console.log("[TIMER] Verificando se SYNC precisa de novo ciclo");
        if (!animation.sync.cycleInProgress) {
          console.log("[TIMER] Iniciando novo ciclo SYNC");
          animation.sync.cycleInProgress = true;
          startSyncRequest(0);
          setTimeout(() => startSyncRequest(1), 100);
          setTimeout(() => {
            startSyncRequest(2);
            // Liberar a flag ap√≥s iniciar todas as requisi√ß√µes
            setTimeout(() => {
              animation.sync.cycleInProgress = false;
            }, 300);
          }, 200);
        }
      }
    }
    
    if (animation.async.running && !animation.async.isPaused) {
      if (animation.async.activeRequests === 0 && animation.async.animationsInProgress === 0) {
        console.log("[TIMER] Verificando se ASYNC precisa de novo ciclo");
        if (!animation.async.cycleInProgress) {
          console.log("[TIMER] Iniciando novo ciclo ASYNC");
          animation.async.cycleInProgress = true;
          startAsyncRequest(0);
          setTimeout(() => startAsyncRequest(1), 100);
          setTimeout(() => {
            startAsyncRequest(2);
            // Liberar a flag ap√≥s iniciar todas as requisi√ß√µes
            setTimeout(() => {
              animation.async.cycleInProgress = false;
            }, 300);
          }, 200);
        }
      }
    }
  }, 3000);
  
  // Contador de ciclos
  const cycleCounts = {
    sync: 0,
    async: 0
  };
  
  // Armazenar timeouts ativos para manipula√ß√£o de pause/resume
  const activeTimeouts = {
    sync: [],
    async: []
  };
  
  // Armazenar os intervalos para verifica√ß√£o de novos ciclos
  const cycleCheckIntervals = {
    sync: null,
    async: null
  };
  
  // Thread Pools compartilhados
  const threadPools = {
    sync: [1, 2],
    async: [1, 2]
  };
  
  // Fun√ß√£o para adicionar eventos √† lista
  function addEvent(type, message, category = '') {
    // Limitar a 10 eventos mais recentes
    const eventList = document.getElementById(`${type}-events`);
    if (!eventList) return;
    
    // Criar novo item de evento
    const eventItem = document.createElement('li');
    
    // Adicionar timestamp
    const now = new Date();
    const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
    
    eventItem.textContent = `${timestamp} - ${message}`;
    
    // Adicionar classe para estilo
    if (category) {
      eventItem.classList.add(`event-${category}`);
    }
    
    // Adicionar ao in√≠cio da lista (mais recente primeiro)
    eventList.insertBefore(eventItem, eventList.firstChild);
    
    // Manter apenas os 10 mais recentes
    while (eventList.children.length > 10) {
      eventList.removeChild(eventList.lastChild);
    }
    
    // Log no console tamb√©m
    console.log(`[${type.toUpperCase()}] ${message}`);
  }

  // Estado global de anima√ß√£o
  const animation = {
    globalStartTime: 0,
    globalTimerIntervalId: null,
    globalTotalPauseTime: 0,
    globalPauseStartTime: 0,
    sync: {
      running: false,
      completed: 0,
      blocked: 0,
      available: 2,
      startTime: 0,
      pauseStartTime: 0,
      totalPauseTime: 0,
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: [],
      activeRequests: 0, // Contador de requisi√ß√µes ativas atualmente
      cycleInProgress: false // Flag para indicar se um ciclo est√° em andamento
    },
    async: {
      running: false,
      completed: 0,
      available: 2,
      blocked: 0,
      startTime: 0,
      pauseStartTime: 0,
      totalPauseTime: 0,
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: [],
      activeRequests: 0, // Contador de requisi√ß√µes ativas atualmente
      cycleInProgress: false // Flag para indicar se um ciclo est√° em andamento
    }
  };

  // Selecionar elementos DOM
  const elements = {
    syncDiagram: document.getElementById('sync-diagram'),
    asyncDiagram: document.getElementById('async-diagram'),
    syncCompleted: document.getElementById('sync-completed'),
    asyncCompleted: document.getElementById('async-completed'),
    playBoth: document.getElementById('play-both'),
    pauseBoth: document.getElementById('pause-both'),
    resetBoth: document.getElementById('reset-both'),
    globalTimer: document.getElementById('global-timer')
  };

  // Event listeners para os controles centrais
  document.getElementById('play-both').addEventListener('click', startBothAnimations);
  document.getElementById('pause-both').addEventListener('click', pauseBothAnimations);
  document.getElementById('reset-both').addEventListener('click', resetBothAnimations);

  // Fun√ß√£o utilit√°ria para criar uma setinha (requisi√ß√£o)
  function createArrow(diagram, x, y, text, color) {
    const arrow = document.createElement('div');
    arrow.className = 'arrow';
    arrow.textContent = text || '=>';
    arrow.style.left = x + 'px';
    arrow.style.top = y + 'px';
    if (color) arrow.style.color = color;
    diagram.appendChild(arrow);
    return arrow;
  }

  // Timeout vers√£o aprimorada que gerencia pausas
  function createTimeout(callback, delay, type) {
    if (animation[type].isPaused) {
      // Se j√° estiver pausado, apenas registra para retomar depois
      const timeoutObj = { callback, delay, remaining: delay };
      activeTimeouts[type].push(timeoutObj);
      return timeoutObj;
    }
    
    const start = Date.now();
    const timeoutObj = {
      id: setTimeout(function() {
        // Remover da lista de timeouts ativos
        const index = activeTimeouts[type].indexOf(timeoutObj);
        if (index > -1) {
          activeTimeouts[type].splice(index, 1);
        }
        callback();
      }, delay),
      callback,
      delay,
      start,
      remaining: delay
    };
    
    activeTimeouts[type].push(timeoutObj);
    return timeoutObj;
  }
  
  // Pausar todos os timeouts ativos
  function pauseAllTimeouts(type) {
    activeTimeouts[type].forEach(timeoutObj => {
      clearTimeout(timeoutObj.id);
      timeoutObj.remaining = timeoutObj.delay - (Date.now() - timeoutObj.start);
      if (timeoutObj.remaining < 0) timeoutObj.remaining = 0;
    });
  }
  
  // Retomar todos os timeouts pausados
  function resumeAllTimeouts(type) {
    activeTimeouts[type].forEach(timeoutObj => {
      timeoutObj.id = setTimeout(function() {
        // Remover da lista de timeouts ativos
        const index = activeTimeouts[type].indexOf(timeoutObj);
        if (index > -1) {
          activeTimeouts[type].splice(index, 1);
        }
        timeoutObj.callback();
      }, timeoutObj.remaining);
      timeoutObj.start = Date.now();
    });
  }

  // Move "elem" de (x1, y1) para (x2, y2) em 'duration' ms
  function moveElement(elem, x1, y1, x2, y2, duration, callback, type) {
    if (!elem || !document.body.contains(elem)) {
      // Se o elemento n√£o existe, garantir que decrementamos o contador
      if (type) {
        animation[type].animationsInProgress--;
        if (animation[type].animationsInProgress < 0) animation[type].animationsInProgress = 0;
      }
      return;
    }
    
    const steps = 40;
    let step = 0;
    const interval = duration / steps;
    const dx = (x2 - x1) / steps;
    const dy = (y2 - y1) / steps;

    // Incrementar contador de anima√ß√µes em andamento
    if (type) {
      animation[type].animationsInProgress++;
    }

    // Se estiver pausado, salvar para retomar depois
    if (type && animation[type].isPaused) {
      const pausedAnimation = {
        elem, x1, y1, x2, y2, duration, callback, type,
        currentX: x1, currentY: y1, step: 0
      };
      animation[type].pausedAnimations.push(pausedAnimation);
      return;
    }

    let animId;
    const anim = () => {
      // Verificar se o elemento ainda existe
      if (!elem || !document.body.contains(elem)) {
        cancelAnimationFrame(animId);
        if (type) {
          animation[type].animationsInProgress--;
          if (animation[type].animationsInProgress < 0) animation[type].animationsInProgress = 0;
        }
        return;
      }
      
      // Verificar se a anima√ß√£o ainda est√° em execu√ß√£o
      if (type && !animation[type].running) {
        cancelAnimationFrame(animId);
        if (type) {
          animation[type].animationsInProgress--;
          if (animation[type].animationsInProgress < 0) animation[type].animationsInProgress = 0;
        }
        return;
      }
      
      // Se estiver pausado, interromper
      if (type && animation[type].isPaused) {
        cancelAnimationFrame(animId);
        const pausedAnimation = {
          elem, x1, y1, x2, y2, duration, callback, type,
          currentX: elem.style.left.replace('px', '') || x1,
          currentY: elem.style.top.replace('px', '') || y1,
          step
        };
        animation[type].pausedAnimations.push(pausedAnimation);
        return;
      }

      step++;
      const nx = x1 + dx * step;
      const ny = y1 + dy * step;
      elem.style.left = nx + 'px';
      elem.style.top = ny + 'px';
      if (step >= steps) {
        cancelAnimationFrame(animId);
        // Decrementar contador de anima√ß√µes em andamento
        if (type) {
          animation[type].animationsInProgress--;
          if (animation[type].animationsInProgress < 0) animation[type].animationsInProgress = 0;
        }
        if (callback) callback();
        return;
      }
      
      animId = requestAnimationFrame(anim);
    };
    
    animId = requestAnimationFrame(anim);
  }

  // Limpa as setas antigas e reseta o estado
  function clearArrows(diagram) {
    if (!diagram) return;
    
    // Remover setas
    const oldArrows = diagram.querySelectorAll('.arrow');
    oldArrows.forEach(a => a.remove());
    
    // Reset any waiting indicators
    const clients = diagram.querySelectorAll('.client-box');
    clients.forEach(c => c.classList.remove('waiting'));
    
    // Reset thread status
    const threads = diagram.querySelectorAll('.thread-box');
    threads.forEach(t => t.classList.remove('thread-blocked'));
  }
  
  // Helper to get thread positions
  function getThreadPosition(diagram, threadNumber) {
    if (!diagram) return null;
    
    const threads = diagram.querySelectorAll('.thread-box');
    if (threadNumber <= threads.length) {
      const thread = threads[threadNumber - 1];
      const rect = thread.getBoundingClientRect();
      const diagramRect = diagram.getBoundingClientRect();
      return {
        x: parseInt(thread.style.left) || (rect.left - diagramRect.left + 10),
        y: parseInt(thread.style.top) || (rect.top - diagramRect.top + 15)
      };
    }
    return null;
  }

  // Atualizar contadores
  function updateCounters(type) {
    if (type === 'sync') {
      elements.syncCompleted.textContent = animation.sync.completed;
    } else {
      elements.asyncCompleted.textContent = animation.async.completed;
    }
  }

  // Fun√ß√£o para atualizar o timer global
  function updateGlobalTimer() {
    if (!animation.globalStartTime) return;
    
    // Se estiver pausado, n√£o atualizar o tempo
    if (animation.sync.isPaused || animation.async.isPaused) return;
    
    const elapsed = (Date.now() - animation.globalStartTime - animation.globalTotalPauseTime) / 1000;
    elements.globalTimer.textContent = `Tempo: ${Math.floor(elapsed)}s`;
  }
  
  // Verificar e iniciar novo ciclo se necess√°rio
  function checkAndStartNewCycle(type) {
    if (animation[type].isPaused) return;
    
    // Se n√£o houver requisi√ß√µes ativas e n√£o houver anima√ß√µes em andamento, iniciar novo ciclo
    if (animation[type].activeRequests === 0 && animation[type].animationsInProgress === 0 && !animation[type].cycleInProgress) {
      addEvent(type, `Iniciando novo ciclo automaticamente`, 'thread');
      console.log(`[${type.toUpperCase()}] Starting new cycle automatically`);
      
      animation[type].cycleInProgress = true;
      cycleCounts[type]++;
      
      // Limpar setas antigas
      const diagram = type === 'sync' ? elements.syncDiagram : elements.asyncDiagram;
      clearArrows(diagram);
      
      // Restaurar pool de threads
      threadPools[type] = [1, 2];
      
      // Iniciar tr√™s novas requisi√ß√µes com pequenos atrasos
      setTimeout(() => {
        if (!animation[type].running || animation[type].isPaused) {
          animation[type].cycleInProgress = false;
          return;
        }
        
        if (type === 'sync') {
          startSyncRequest(0);
          setTimeout(() => startSyncRequest(1), 100);
          setTimeout(() => startSyncRequest(2), 200);
        } else {
          startAsyncRequest(0);
          setTimeout(() => startAsyncRequest(1), 100);
          setTimeout(() => startAsyncRequest(2), 200);
        }
        
        // Reset da flag de ciclo em andamento
        setTimeout(() => {
          animation[type].cycleInProgress = false;
        }, 300);
      }, 200);
    }
  }
  
  // Monitor de estado - para diagn√≥stico
  function setupStateMonitor() {
    setInterval(() => {
      if (DEBUG) {
        const syncState = {
          running: animation.sync.running,
          isPaused: animation.sync.isPaused,
          activeRequests: animation.sync.activeRequests,
          animationsInProgress: animation.sync.animationsInProgress,
          cycleInProgress: animation.sync.cycleInProgress,
          poolSize: threadPools.sync.length,
          cycles: cycleCounts.sync
        };
        
        const asyncState = {
          running: animation.async.running,
          isPaused: animation.async.isPaused,
          activeRequests: animation.async.activeRequests,
          animationsInProgress: animation.async.animationsInProgress,
          cycleInProgress: animation.async.cycleInProgress,
          poolSize: threadPools.async.length,
          cycles: cycleCounts.async
        };
        
        console.log("Estado atual:");
        console.log("SYNC:", syncState);
        console.log("ASYNC:", asyncState);
      }
    }, 5000);
  }
  
  // Iniciar anima√ß√£o
  function startAnimation(type) {
    if (animation[type].running && !animation[type].isPaused) return;
    
    // Se estiver pausado, resumir
    if (animation[type].isPaused) {
      resumeAnimation(type);
      return;
    }
    
    // Resetar primeiro, mas manter o contador se j√° estava em execu√ß√£o
    const wasRunningBefore = animation[type].running;
    resetAnimation(type, true); // true = manter contadores
    
    // Configurar estado
    animation[type].running = true;
    animation[type].startTime = Date.now();
    animation[type].totalPauseTime = 0;
    
    // Restaurar pool de threads
    threadPools[type] = [1, 2];
    
    addEvent(type, `Iniciando anima√ß√£o ${type === 'sync' ? 's√≠ncrona' : 'ass√≠ncrona'}`, 'thread');
    
    // Iniciar fluxo apropriado
    if (type === 'sync') {
      startSync();
    } else {
      startAsync();
    }
    
    // Limpar qualquer intervalo anterior antes de criar um novo
    if (cycleCheckIntervals[type]) {
      clearInterval(cycleCheckIntervals[type]);
    }
    
    // Iniciar verifica√ß√£o peri√≥dica para novos ciclos e armazenar o ID do intervalo
    cycleCheckIntervals[type] = setInterval(() => checkAndStartNewCycle(type), 500);
  }
  
  // Pausar anima√ß√£o
  function pauseAnimation(type) {
    if (!animation[type].running || animation[type].isPaused) return;
    
    // Gravar o tempo de in√≠cio da pausa
    animation[type].isPaused = true;
    animation[type].pauseStartTime = Date.now();
    
    // Pausar todos os timeouts
    pauseAllTimeouts(type);
    
    addEvent(type, `Anima√ß√£o pausada`, 'thread');
    console.log(`[${type.toUpperCase()}] Animation paused at ${animation[type].pauseStartTime}`);
  }
  
  // Pausar ambas anima√ß√µes
  function pauseBothAnimations() {
    pauseAnimation('sync');
    pauseAnimation('async');
    
    // Pausar timer global
    animation.globalPauseStartTime = Date.now();
    
    // Parar o intervalo do timer global
    clearInterval(animation.globalTimerIntervalId);
    
    elements.pauseBoth.disabled = true;
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Continuar';
  }
  
  // Resumir anima√ß√£o
  function resumeAnimation(type) {
    if (!animation[type].running || !animation[type].isPaused) return;
    
    // Calcular o tempo total de pausa
    const pauseDuration = Date.now() - animation[type].pauseStartTime;
    animation[type].totalPauseTime += pauseDuration;
    
    // Desmarcar pausa
    animation[type].isPaused = false;
    
    addEvent(type, `Anima√ß√£o retomada`, 'thread');
    console.log(`[${type.toUpperCase()}] Animation resumed. Pause duration: ${pauseDuration}ms, Total pause: ${animation[type].totalPauseTime}ms`);
    
    // Retomar timeouts
    resumeAllTimeouts(type);
    
    // Retomar anima√ß√µes pausadas
    const pausedAnimations = [...animation[type].pausedAnimations];
    animation[type].pausedAnimations = [];
    
    pausedAnimations.forEach(anim => {
      moveElement(
        anim.elem, 
        parseFloat(anim.currentX), 
        parseFloat(anim.currentY), 
        anim.x2, 
        anim.y2, 
        anim.duration * (1 - anim.step / 40), 
        anim.callback,
        anim.type
      );
    });
    
    // Verificar se precisamos iniciar um novo ciclo
    checkAndStartNewCycle(type);
  }
  
  // Resetar anima√ß√£o (sem resetar contadores entre ciclos)
  function resetAnimation(type, keepCounters = false) {
    console.log(`[${type.toUpperCase()}] Resetting animation`);
    
    // Parar qualquer anima√ß√£o em andamento
    clearInterval(animation[type].intervalId);
    
    // Limpar o intervalo de verifica√ß√£o de ciclos
    if (cycleCheckIntervals[type]) {
      clearInterval(cycleCheckIntervals[type]);
      cycleCheckIntervals[type] = null;
    }
    
    // Limpar todos os timeouts ativos
    for (const timeoutObj of activeTimeouts[type]) {
      clearTimeout(timeoutObj.id);
    }
    activeTimeouts[type] = [];
    
    // Limpar setas
    clearArrows(document.getElementById(`${type}-diagram`));
    
    // Limpar a lista de eventos
    const eventList = document.getElementById(`${type}-events`);
    if (eventList) {
      while (eventList.firstChild) {
        eventList.removeChild(eventList.firstChild);
      }
    }
    
    // Resetar estado
    animation[type].running = false;
    animation[type].animationsInProgress = 0;
    animation[type].isPaused = false;
    animation[type].pausedAnimations = [];
    animation[type].totalPauseTime = 0;
    animation[type].activeRequests = 0;
    animation[type].cycleInProgress = false;
    
    // Resetar contador de ciclos
    if (!keepCounters) {
      cycleCounts[type] = 0;
    }
    
    // Resetar threads (mas n√£o o contador de requisi√ß√µes se keepCounters=true)
    if (type === 'sync') {
      animation.sync.blocked = 0;
      animation.sync.available = 2;
      if (!keepCounters) {
        animation.sync.completed = 0;
      }
    } else {
      animation.async.blocked = 0;
      animation.async.available = 2;
      if (!keepCounters) {
        animation.async.completed = 0;
      }
    }
    
    // Restaurar pool de threads
    threadPools[type] = [1, 2];
    
    // Atualizar contadores
    updateCounters(type);
    
    // Resetar status
    const statusIndicator = document.querySelector(`#${type}-diagram .status-indicator`);
    if (statusIndicator) {
      statusIndicator.textContent = 'Pronto para iniciar';
      statusIndicator.style.fontWeight = '';
      statusIndicator.style.color = '';
      statusIndicator.style.fontSize = '';
      statusIndicator.style.backgroundColor = '';
      statusIndicator.style.border = '';
    }
  }
  
  // Iniciar ambas anima√ß√µes
  function startBothAnimations() {
    if (animation.sync.isPaused || animation.async.isPaused) {
      // Se estiver pausado, continuar
      resumeAnimation('sync');
      resumeAnimation('async');
      
      // Retomar timer global
      const pauseDuration = Date.now() - animation.globalPauseStartTime;
      animation.globalTotalPauseTime += pauseDuration;
      
      // Reiniciar o intervalo do timer global
      animation.globalTimerIntervalId = setInterval(updateGlobalTimer, 100);
      
      elements.playBoth.disabled = true;
      elements.pauseBoth.disabled = false;
      elements.playBoth.textContent = '‚ñ∂Ô∏è Iniciar Compara√ß√£o';
      return;
    }
    
    // Iniciar timer global
    animation.globalStartTime = Date.now();
    animation.globalTotalPauseTime = 0;
    animation.globalTimerIntervalId = setInterval(updateGlobalTimer, 100);
    
    // Iniciar o monitor de estado
    setupStateMonitor();
    
    startAnimation('sync');
    startAnimation('async');
    
    elements.playBoth.disabled = true;
    elements.pauseBoth.disabled = false;
  }
  
  // Resetar ambas anima√ß√µes (incluindo contadores de requisi√ß√µes)
  function resetBothAnimations() {
    // Primeiro resetamos a anima√ß√£o
    resetAnimation('sync', false); // false = n√£o manter contadores
    resetAnimation('async', false); // false = n√£o manter contadores
    
    // Parar e resetar timer global
    clearInterval(animation.globalTimerIntervalId);
    animation.globalStartTime = 0;
    animation.globalTotalPauseTime = 0;
    elements.globalTimer.textContent = 'Tempo: 0s';
    
    // Agora tamb√©m resetamos os contadores de requisi√ß√µes completadas
    animation.sync.completed = 0;
    animation.async.completed = 0;
    
    // Atualizar contadores na interface
    updateCounters('sync');
    updateCounters('async');
    
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Iniciar Compara√ß√£o';
    elements.pauseBoth.disabled = true;
  }

  /* ======================================
       FLUXO S√çNCRONO
     ====================================== */
  function startSync() {
    const diagram = elements.syncDiagram;
    clearArrows(diagram);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    statusIndicator.textContent = 'Iniciando requisi√ß√µes s√≠ncronas...';

    // Start requests with slight delays
    if (!animation.sync.isPaused) {
      setTimeout(() => startSyncRequest(0), 200);
      setTimeout(() => {
        if (!animation.sync.isPaused) startSyncRequest(1);
      }, 800);
      setTimeout(() => {
        if (!animation.sync.isPaused) startSyncRequest(2);
      }, 1400);
    }
  }
  
  function startSyncRequest(index) {
    if (!animation.sync.running || animation.sync.isPaused) return;
    
    // Incrementar contador de requisi√ß√µes ativas
    animation.sync.activeRequests++;
    
    const diagram = elements.syncDiagram;
    
    // Posi√ß√µes iniciais das setinhas (3 clientes)
    const requests = [
      { x: 50, y: 75, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 165, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 255, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    const request = requests[index];
    
    // Create arrow with id badge
    const arrow = createArrow(diagram, request.x, request.y, '=>', request.color);
    const requestBadge = document.createElement('div');
    requestBadge.className = 'request-id';
    requestBadge.style.backgroundColor = request.color;
    requestBadge.textContent = request.id;
    arrow.appendChild(requestBadge);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    
    // Verificar quantas threads dispon√≠veis
    addEvent('sync', `Req ${request.id} iniciada, threads: ${threadPools.sync.length}`, 'request');
    
    // Check if a thread is available
    if (threadPools.sync.length > 0) {
      // Get a thread from the pool
      const threadNumber = threadPools.sync.shift();
      
      // Atualizar contadores internos
      animation.sync.blocked++;
      animation.sync.available = threadPools.sync.length;
      
      const threadPos = getThreadPosition(diagram, threadNumber);
      
      // Get the thread element
      const threadElements = diagram.querySelectorAll('.thread-box');
      const threadElem = threadElements[threadNumber - 1];
      
      // Client -> Thread
      statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
      moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
        if (!animation.sync.running) return;
        
        // Thread processing - mark thread as assigned
        statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id}`;
        addEvent('sync', `Thread ${threadNumber} processando req ${request.id}`, 'thread');
        
        // Thread -> DB (Thread is blocked during this operation)
        if (threadElem && document.body.contains(threadElem)) {
          threadElem.classList.add('thread-blocked'); // Mark thread as blocked
          addEvent('sync', `Thread ${threadNumber} bloqueada`, 'wait');
        }
        
        moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
          if (!animation.sync.running) return;
          
          // "Bloqueado" por 2s no DB
          statusIndicator.textContent = `Thread ${threadNumber} BLOQUEADA aguardando DB (SYNC, bloqueia thread)`;
          addEvent('sync', `Aguardando DB por 2s (Thread ${threadNumber} bloqueada)`, 'db');
          
          // Timeout para simular opera√ß√£o de I/O
          setTimeout(() => {
            if (!animation.sync.running) return;
            
            // Return DB -> Thread
            statusIndicator.textContent = `Banco de dados respondeu para requisi√ß√£o ${request.id}`;
            addEvent('sync', `DB respondeu para req ${request.id}`, 'db');
            if (arrow && document.body.contains(arrow)) {
              arrow.classList.add('return');
              moveElement(arrow, 350, threadPos.y, threadPos.x, threadPos.y, 700, () => {
                if (!animation.sync.running) return;
                
                // Thread -> Client
                statusIndicator.textContent = `Thread ${threadNumber} enviando resposta ao cliente (req. ${request.id})`;
                moveElement(arrow, threadPos.x, threadPos.y, request.x, request.y, 700, () => {
                  if (!animation.sync.running) return;
                  
                  // Return thread to the pool
                  if (threadElem && document.body.contains(threadElem)) {
                    threadElem.classList.remove('thread-blocked'); // Unblock thread
                  }
                  threadPools.sync.push(threadNumber);
                  
                  // Atualizar contadores
                  animation.sync.blocked--;
                  animation.sync.completed++;
                  animation.sync.available = threadPools.sync.length;
                  animation.sync.activeRequests--; // Decrementar contador de requisi√ß√µes ativas
                  updateCounters('sync');
                  
                  addEvent('sync', `Req ${request.id} completa, thread ${threadNumber} liberada`, 'complete');
                  
                  statusIndicator.textContent = `Thread ${threadNumber} liberada, voltou para o pool`;
                  
                  // Check if there are waiting clients and process them
                  const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                  if (waitingClients.length > 0) {
                    waitingClients[0].classList.remove('waiting');
                    const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                    const waitingIndex = requests.findIndex(r => r.id === waitingId);
                    
                    console.log(`[SYNC] Starting waiting request ${waitingId}`);
                    
                    // Start waiting request after a small delay
                    setTimeout(() => startSyncRequest(waitingIndex), 300);
                  }
                  
                  // Verificar se precisamos iniciar um novo ciclo
                  checkAndStartNewCycle('sync');
                }, 'sync');
              }, 'sync');
            }
          }, 2000);
        }, 'sync');
      }, 'sync');
    } else {
      // No thread available, make the client "wait"
      const clients = diagram.querySelectorAll('.client-box');
      clients[request.clientIndex].classList.add('waiting');
      statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel (pool esgotado)`;
      addEvent('sync', `Req ${request.id} espera por thread (pool vazio)`, 'wait');
    }
  }

  /* ======================================
       FLUXO ASS√çNCRONO
     ====================================== */
  function startAsync() {
    const diagram = elements.asyncDiagram;
    clearArrows(diagram);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    statusIndicator.textContent = 'Iniciando requisi√ß√µes ass√≠ncronas...';
    
    // Start requests with slight delays - same timing as sync for comparison
    if (!animation.async.isPaused) {
      setTimeout(() => startAsyncRequest(0), 200);
      setTimeout(() => {
        if (!animation.async.isPaused) startAsyncRequest(1);
      }, 800);
      setTimeout(() => {
        if (!animation.async.isPaused) startAsyncRequest(2);
      }, 1400);
    }
  }
  
  function startAsyncRequest(index) {
    if (!animation.async.running || animation.async.isPaused) return;
    
    // Incrementar contador de requisi√ß√µes ativas
    animation.async.activeRequests++;
    
    const diagram = elements.asyncDiagram;
    const requests = [
      { x: 50, y: 65, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 145, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 225, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    const request = requests[index];
    
    // Track pending I/O operations for visualization
    const pendingDbOperationsRef = { operations: [] };
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    
    // Create arrow with id badge
    const arrow = createArrow(diagram, request.x, request.y, '=>', request.color);
    const requestBadge = document.createElement('div');
    requestBadge.className = 'request-id';
    requestBadge.style.backgroundColor = request.color;
    requestBadge.textContent = request.id;
    arrow.appendChild(requestBadge);
    
    addEvent('async', `Req ${request.id} iniciada, threads: ${threadPools.async.length}`, 'request');
    
    // Check if a thread is available
    if (threadPools.async.length > 0) {
      // Get a thread from the pool
      const threadNumber = threadPools.async.shift();
      
      // Atualizar contadores internos
      animation.async.blocked++;
      animation.async.available = threadPools.async.length;
      
      const threadPos = getThreadPosition(diagram, threadNumber);
      
      // Get the thread element
      const threadElements = diagram.querySelectorAll('.thread-box');
      const threadElem = threadElements[threadNumber - 1];
      
      // Client -> Thread
      statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
      moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
        if (!animation.async.running) return;
        
        // Thread processing - brief CPU work
        statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id} (setup)`;
        addEvent('async', `Thread ${threadNumber} processando req ${request.id}`, 'thread');
        
        // Quick thread work (async setup)
        setTimeout(() => {
          if (!animation.async.running) return;
          
          // *** Thread is released here (await) - KEY DIFFERENCE ***
          statusIndicator.textContent = `Thread ${threadNumber} encontrou await, RETORNANDO AO POOL (ASYNC)`;
          
          // Return thread to the pool immediately
          threadPools.async.push(threadNumber);
          
          // Atualizar contadores
          animation.async.blocked--;
          animation.async.available = threadPools.async.length;
          
          addEvent('async', `Thread ${threadNumber} liberada no await`, 'thread');
          
          // Check if there are waiting clients and process them
          const waitingClients = diagram.querySelectorAll('.client-box.waiting');
          if (waitingClients.length > 0) {
            waitingClients[0].classList.remove('waiting');
            const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
            const waitingIndex = requests.findIndex(r => r.id === waitingId);
            
            statusIndicator.textContent = `Thread ${threadNumber} dispon√≠vel para requisi√ß√£o ${waitingId}`;
            console.log(`[ASYNC] Starting waiting request ${waitingId} with newly available thread`);
            
            // Start waiting request after a small delay
            setTimeout(() => startAsyncRequest(waitingIndex), 300);
          }
          
          // Arrow continues to DB without blocking thread
          statusIndicator.textContent = `Requisi√ß√£o ${request.id} continua para o DB (sem thread bloqueado)`;
          moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
            if (!animation.async.running) return;
            
            // Add to pending DB operations
            pendingDbOperationsRef.operations.push(request.id);
            
            // I/O operation in DB
            statusIndicator.textContent = `Requisi√ß√£o ${request.id} executando no banco de dados (I/O ass√≠ncrono)`;
            addEvent('async', `Req ${request.id} executando no DB por 2s`, 'db');
            
            // Timeout para simular opera√ß√£o de I/O - same time as sync for comparison
            setTimeout(() => {
              if (!animation.async.running) return;
              
              // Remove from pending operations
              pendingDbOperationsRef.operations = pendingDbOperationsRef.operations.filter(id => id !== request.id);
              
              // Get thread for completion (might be different thread)
              if (threadPools.async.length === 0) {
                statusIndicator.textContent = `Requisi√ß√£o ${request.id} aguardando thread dispon√≠vel (opera√ß√£o I/O completou)`;
                
                // We'll check periodically if a thread becomes available
                const checkInterval = setInterval(() => {
                  if (!animation.async.running) {
                    clearInterval(checkInterval);
                    return;
                  }
                  
                  if (threadPools.async.length > 0) {
                    clearInterval(checkInterval);
                    continueAfterDb();
                  }
                }, 300);
              } else {
                continueAfterDb();
              }
              
              function continueAfterDb() {
                if (!animation.async.running) return;
                
                // Verificar se o pool foi esvaziado por algum erro
                if (threadPools.async.length === 0) {
                  console.log("Erro: Thread pool async est√° vazio. Restaurando...");
                  threadPools.async = [1, 2];
                }
                
                const returnThreadNumber = threadPools.async.shift();
                
                // Atualizar contadores internos
                animation.async.blocked++;
                animation.async.available = threadPools.async.length;
                
                const returnThreadPos = getThreadPosition(diagram, returnThreadNumber);
                const returnThreadElements = diagram.querySelectorAll('.thread-box');
                const returnThreadElem = returnThreadElements[returnThreadNumber - 1];
                
                // Response DB -> Thread
                statusIndicator.textContent = `Banco respondeu! Req. ${request.id} obt√©m Thread ${returnThreadNumber} (pode ser diferente)`;
                addEvent('async', `DB respondeu para req ${request.id}`, 'db');
                
                if (arrow && document.body.contains(arrow)) {
                  arrow.classList.add('return');
                  moveElement(arrow, 350, threadPos.y, returnThreadPos.x, returnThreadPos.y, 700, () => {
                    if (!animation.async.running) return;
                    
                    // Quick completion work
                    statusIndicator.textContent = `Thread ${returnThreadNumber} finalizando requisi√ß√£o ${request.id} (p√≥s-await)`;
                    
                    setTimeout(() => {
                      if (!animation.async.running) return;
                      
                      // Thread -> Client
                      statusIndicator.textContent = `Thread ${returnThreadNumber} enviando resposta (req. ${request.id})`;
                      
                      moveElement(arrow, returnThreadPos.x, returnThreadPos.y, request.x, request.y, 700, () => {
                        if (!animation.async.running) return;
                        
                        // Return thread to pool
                        threadPools.async.push(returnThreadNumber);
                        
                        // Atualizar contadores
                        animation.async.blocked--;
                        animation.async.completed++;
                        animation.async.available = threadPools.async.length;
                        animation.async.activeRequests--; // Decrementar contador de requisi√ß√µes ativas
                        updateCounters('async');
                        
                        addEvent('async', `Req ${request.id} completa, thread ${returnThreadNumber} liberada`, 'complete');
                        
                        statusIndicator.textContent = `Thread ${returnThreadNumber} liberada, voltou para o pool`;
                        
                        // Check again for waiting clients
                        const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                        if (waitingClients.length > 0) {
                          waitingClients[0].classList.remove('waiting');
                          const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                          const waitingIndex = requests.findIndex(r => r.id === waitingId);
                          
                          console.log(`[ASYNC] Starting waiting request ${waitingId}`);
                          
                          // Start waiting request after a small delay
                          setTimeout(() => startAsyncRequest(waitingIndex), 300);
                        }
                        
                        // Verificar se precisamos iniciar um novo ciclo
                        checkAndStartNewCycle('async');
                      }, 'async');
                    }, 300);
                  }, 'async');
                }
              }
            }, 2000);
          }, 'async');
        }, 500);
      }, 'async');
    } else {
      // No thread available, make the client "wait"
      const clients = diagram.querySelectorAll('.client-box');
      clients[request.clientIndex].classList.add('waiting');
      statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel (pool esgotado)`;
      addEvent('async', `Req ${request.id} espera por thread (pool vazio)`, 'wait');
    }
  }
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Exemplo Did√°tico - Sync vs. Async</title>
  <!-- Bootstrap CSS -->
  <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
  <style>
    body {
      background: #f8f9fa;
      padding-top: 20px;
    }
    
    .card {
      box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
      margin-bottom: 20px;
    }
    
    /* Event Log Styles */
    .event-log {
      position: absolute;
      top: 50px;
      width: 210px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 0;
      z-index: 10;
      max-height: 250px;
      overflow-y: auto;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    /* Event List Styles */
    .event-list-card {
      list-style: none;
      margin: 0;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .event-list-card li {
      font-size: 12px;
      padding: 6px 10px;
      border-bottom: 1px solid #eee;
      color: #333;
    }
    
    .event-list-card li:nth-child(odd) {
      background-color: #f9f9f9;
    }
    
    .event-list-card li.event-request { color: #0275d8; }
    .event-list-card li.event-thread { color: #5cb85c; }
    .event-list-card li.event-db { color: #f0ad4e; }
    .event-list-card li.event-complete { color: #5bc0de; }
    .event-list-card li.event-wait { color: #d9534f; }
    
    /* BOUNDARIES - dotted boxes to represent process limits */
    .client-process {
      width: 110px;
      height: 320px;
      border: 2px dotted #6c757d;
      border-radius: 8px;
      background: rgba(108, 117, 125, 0.05);
      position: absolute;
      left: 10px;
      top: 25px;
    }
    .client-process-label {
      position: absolute;
      top: 5px;
      left: 20px;
      font-size: 12px;
      font-weight: bold;
      color: #6c757d;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* SERVER PROCESS - middle */
    .server-process {
      width: 160px;
      height: 320px;
      border: 2px dotted #5bc0de;
      border-radius: 8px;
      background: rgba(91, 192, 222, 0.05);
      position: absolute;
      left: 140px;
      top: 25px;
    }
    .server-process-label {
      position: absolute;
      top: 5px;
      left: 180px;
      font-size: 12px;
      font-weight: bold;
      color: #5bc0de;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DATABASE PROCESS - right side */
    .db-process {
      width: 90px;
      height: 120px;
      border: 2px dotted #f0ad4e;
      border-radius: 8px;
      background: rgba(240, 173, 78, 0.05);
      position: absolute;
      left: 320px;
      top: 120px;
    }
    .db-process-label {
      position: absolute;
      top: 100px;
      left: 335px;
      font-size: 12px;
      font-weight: bold;
      color: #f0ad4e;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DIAGRAMA */
    .diagram {
      position: relative;
      width: 100%;
      height: 380px;
      border: 1px dashed #dee2e6;
      overflow: hidden;
      background: #f9f9f9;
      border-radius: 0.25rem;
      margin-bottom: 10px;
    }
    
    /* CLIENTES (3) - quadradinhos √† esquerda */
    .client-box {
      width: 90px; 
      height: 36px;
      background: #cfe2ff;  /* azul claro */
      border: 2px solid #6ea8fe; 
      border-radius: 5px;
      color: #333;
      text-align: center;
      line-height: 36px;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
      padding-left: 16px; /* Espa√ßo para o √≠cone */
    }
    .client-box::before {
      content: "üåê";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
    }

    /* THREAD POOL (ret√¢ngulo grande com leve destaque) */
    .thread-pool {
      width: 120px;
      height: 180px;
      border: 2px dashed #5cb85c;
      border-radius: 5px;
      background: #f0fff0;
      position: absolute;
      left: 160px;
      top: 100px;
      z-index: 1;
    }
    .thread-pool-label {
      position: absolute;
      width: 120px;
      text-align: center;
      font-weight: bold;
      color: #5cb85c;
      left: 160px;
      top: 75px;
      font-size: 14px;
      z-index: 2;
    }

    /* THREADS dentro do pool (ret√¢ngulos) */
    .thread-box {
      width: 100px; 
      height: 35px;
      border: 2px solid #5cb85c; 
      background: #e3f9e3;
      border-radius: 5px;
      text-align: center;
      line-height: 35px;
      color: #333;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
    }
    .thread-box::before {
      content: "‚öôÔ∏è";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }
    
    /* Thread bloqueada */
    .thread-blocked {
      background: #ffcccc !important;
      border-color: #dc3545 !important;
      color: #dc3545;
    }
    .thread-blocked::after {
      content: "üîí";
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }

    /* BANCO DE DADOS (ret√¢ngulo/cilindro estilizado) */
    .database {
      width: 60px;
      height: 80px;
      border: 2px solid #f0ad4e;
      border-radius: 5px;
      background: #fdf6ea; /* Amarelinho */
      color: #f0ad4e;
      text-align: center;
      line-height: 80px;
      font-weight: bold;
      position: absolute;
      left: 335px;
      top: 140px;
      z-index: 2;
    }

    /* SETAS (requisi√ß√µes) - vamos usar divs pequenas com texto "=>" para simbolizar setinhas em movimento */
    .arrow {
      position: absolute;
      font-size: 22px;
      font-weight: bold;
      user-select: none;
      pointer-events: none;
      z-index: 3;
      background: rgba(255, 255, 255, 0.7);
      padding: 0 3px;
      border-radius: 3px;
    }
    /* Setas que est√£o "voltando" (vermelho, p.ex.) */
    .arrow.return {
      color: #dc3545;
    }
    
    /* Request ID badge */
    .request-id {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      color: white;
      text-align: center;
      line-height: 18px;
      font-size: 12px;
      font-weight: bold;
      margin-top: -10px;
      margin-left: 15px;
    }

    /* Visual indicator for request in queue */
    .waiting {
      border: 2px dashed #dc3545 !important;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Estado das opera√ß√µes */
    .status-indicator {
      position: absolute;
      bottom: 20px;
      left: 10px;
      right: 10px;
      height: 36px;
      background: rgba(0, 0, 0, 0.07);
      border-radius: 5px;
      text-align: center;
      line-height: 36px;
      font-weight: bold;
      font-size: 14px;
      color: #666;
      z-index: 10;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    
    /* Contador de requisi√ß√µes */
    .metrics {
      display: flex;
      justify-content: space-around;
      padding: 5px;
      border-top: 1px solid #eee;
    }
    
    /* Compare indicator */
    .comparison-indicator {
      text-align: center;
      padding: 5px 0;
      font-weight: bold;
      font-size: 0.875rem;
    }
    
    /* Legend row */
    .legend-item {
      display: flex;
      align-items: center;
      margin: 0 10px 10px 0;
    }
    
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border-radius: 3px;
      position: relative;
    }

    /* Melhoria de responsividade */
    @media (max-width: 768px) {
      .diagram {
        height: 450px;
      }
      
      .event-list-card {
        max-height: 150px;
      }
      
      .client-process, .server-process, .db-process {
        transform: scale(0.9);
        transform-origin: center;
      }
    }

    /* Melhor centraliza√ß√£o */
    .metrics-row {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 10px;
    }
    
    .metrics-item {
      text-align: center;
      padding: 5px 10px;
      background-color: #f8f9fa;
      border-radius: 5px;
      border: 1px solid #dee2e6;
    }
    
    .badge {
      font-size: 14px;
      font-weight: 600;
      padding: 4px 8px;
      background-color: #6c757d;
    }
    
    .controls-container {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    
    .btn {
      min-width: 120px;
    }
  </style>
</head>
<body>
<div class="container">
  <!-- Header Section -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <h1 class="text-center mb-3">Fluxo S√≠ncrono vs. Ass√≠ncrono em ASP.NET Core</h1>
          <p class="mb-1"><strong>Cen√°rio:</strong> 2 threads no servidor processando 3 requisi√ß√µes simult√¢neas.</p>
          <p class="mb-2"><strong>S√≠ncrono:</strong> Cada thread fica "presa" aguardando o banco de dados (2s), bloqueando o <em>Thread Pool</em> durante opera√ß√µes I/O.</p>
          <p class="mb-2"><strong>Ass√≠ncrono:</strong> Assim que a requisi√ß√£o inicia I/O no DB (com <code>await</code>), a thread √© devolvida ao <em>Thread Pool</em>.</p>
          <p class="mb-0 text-primary"><strong>Observe:</strong> No modo ass√≠ncrono, todas as requisi√ß√µes s√£o processadas mais rapidamente, mesmo com apenas 2 threads dispon√≠veis!</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Control Section -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="controls-container">
            <button id="play-both" class="btn btn-primary">‚ñ∂Ô∏è Iniciar Compara√ß√£o</button>
            <button id="pause-both" class="btn btn-secondary" disabled>‚è∏Ô∏è Pausar</button>
            <button id="reset-both" class="btn btn-outline-secondary">üîÑ Reiniciar</button>
          </div>
          <div class="mt-3 text-center">
            <div id="global-timer" class="badge bg-dark p-2 fs-6">Tempo: 0s</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Diagrams Section -->
  <div class="row">
    <!-- S√≠ncrono -->
    <div class="col-md-6 mb-4">
      <div class="card h-100">
        <div class="card-header bg-danger bg-opacity-25">
          <h5 class="card-title text-center mb-0">S√≠ncrono</h5>
        </div>
        <div class="card-body p-2">
          <div class="diagram" id="sync-diagram">
            <!-- Boundaries -->
            <div class="client-process"></div>
            <div class="client-process-label">Processo Cliente</div>
            
            <div class="server-process"></div>
            <div class="server-process-label">Processo Servidor</div>
            
            <div class="db-process"></div>
            <div class="db-process-label">Banco de Dados</div>
            
            <!-- 3 Clients -->
            <div class="client-box" style="left:20px; top:60px;">Request 1</div>
            <div class="client-box" style="left:20px; top:150px;">Request 2</div>
            <div class="client-box" style="left:20px; top:240px;">Request 3</div>

            <!-- Thread Pool -->
            <div class="thread-pool"></div>
            <div class="thread-pool-label">Thread Pool (2)</div>

            <!-- 2 Threads dentro do pool -->
            <div class="thread-box" style="left:170px; top:120px;">Thread 1</div>
            <div class="thread-box" style="left:170px; top:200px;">Thread 2</div>

            <!-- DB √† direita -->
            <div class="database">DB</div>
            
            <!-- Status Indicator -->
            <div class="status-indicator">Pronto para iniciar</div>
          </div>
          <div class="d-flex justify-content-around mt-2">
            <div>Requisi√ß√µes Completas: <span id="sync-completed" class="badge">0</span></div>
            <div>Threads Dispon√≠veis: <span id="sync-available" class="badge">2</span>/2</div>
            <div>Threads Bloqueadas: <span id="sync-blocked" class="badge">0</span>/2</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Ass√≠ncrono -->
    <div class="col-md-6 mb-4">
      <div class="card h-100">
        <div class="card-header bg-success bg-opacity-25">
          <h5 class="card-title text-center mb-0">Ass√≠ncrono</h5>
        </div>
        <div class="card-body p-2">
          <div class="diagram" id="async-diagram">
            <!-- Boundaries -->
            <div class="client-process"></div>
            <div class="client-process-label">Processo Cliente</div>
            
            <div class="server-process"></div>
            <div class="server-process-label">Processo Servidor</div>
            
            <div class="db-process"></div>
            <div class="db-process-label">Banco de Dados</div>
            
            <!-- 3 Clients -->
            <div class="client-box" style="left:20px; top:50px;">Request 1</div>
            <div class="client-box" style="left:20px; top:130px;">Request 2</div>
            <div class="client-box" style="left:20px; top:210px;">Request 3</div>

            <!-- Thread Pool -->
            <div class="thread-pool"></div>
            <div class="thread-pool-label">Thread Pool (2)</div>

            <!-- 2 Threads dentro do pool -->
            <div class="thread-box" style="left:170px; top:100px;">Thread 1</div>
            <div class="thread-box" style="left:170px; top:180px;">Thread 2</div>

            <!-- DB √† direita -->
            <div class="database">DB</div>
            
            <!-- Status Indicator -->
            <div class="status-indicator">Pronto para iniciar</div>
          </div>
          <div class="d-flex justify-content-around mt-2">
            <div>Requisi√ß√µes Completas: <span id="async-completed" class="badge">0</span></div>
            <div>Threads Dispon√≠veis: <span id="async-available" class="badge">2</span>/2</div>
            <div>Threads Bloqueadas: <span id="async-blocked" class="badge">0</span>/2</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Event Logs Section -->
  <div class="row">
    <!-- Sync Events -->
    <div class="col-md-6 mb-4">
      <div class="card">
        <div class="card-header bg-danger bg-opacity-25">
          <h6 class="card-title mb-0">Eventos S√≠ncronos</h6>
        </div>
        <div class="card-body p-2">
          <ul id="sync-events" class="event-list-card"></ul>
        </div>
      </div>
    </div>
    
    <!-- Async Events -->
    <div class="col-md-6 mb-4">
      <div class="card">
        <div class="card-header bg-success bg-opacity-25">
          <h6 class="card-title mb-0">Eventos Ass√≠ncronos</h6>
        </div>
        <div class="card-body p-2">
          <ul id="async-events" class="event-list-card"></ul>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Legend -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-body">
          <div class="d-flex flex-wrap justify-content-center">
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #cfe2ff; border: 2px solid #6ea8fe; position: relative;">
                <span style="font-size: 14px;">üåê</span>
              </div>
              <span>Requisi√ß√£o Web</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #e3f9e3; border: 2px solid #5cb85c; position: relative;">
                <span style="font-size: 12px;">‚öôÔ∏è</span>
              </div>
              <span>Thread Dispon√≠vel</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #ffcccc; border: 2px solid #dc3545; position: relative;">
                <span style="font-size: 12px;">üîí</span>
              </div>
              <span>Thread Bloqueada</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #f0fff0; border: 2px dashed #5cb85c;"></div>
              <span>Thread Pool</span>
            </div>
            <div class="legend-item">
              <div class="legend-color d-flex align-items-center justify-content-center" style="background: #fdf6ea; border: 2px solid #f0ad4e;"></div>
              <span>Banco de Dados</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Code comparison -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header">
          <h5 class="card-title mb-0">C√≥digo em ASP.NET Core</h5>
        </div>
        <div class="card-body">
          <div class="row">
            <div class="col-md-6">
              <h6 class="text-danger">Abordagem S√≠ncrona</h6>
              <pre><code class="bg-light p-3 d-block">public IEnumerable&lt;Company> GetCompanies()
{
    _logger.LogInfo("Buscando empresas...");
    var companies = _context.Companies.ToList();
    return companies;
}</code></pre>
              <p class="small">O m√©todo s√≠ncrono bloqueia a thread enquanto aguarda o resultado do banco de dados.</p>
            </div>
            <div class="col-md-6">
              <h6 class="text-success">Abordagem Ass√≠ncrona</h6>
              <pre><code class="bg-light p-3 d-block">public async Task&lt;IEnumerable&lt;Company>> GetCompanies()
{
    _logger.LogInfo("Buscando empresas...");
    var companies = await _context.Companies.ToListAsync();
    return companies;
}</code></pre>
              <p class="small">O m√©todo ass√≠ncrono libera a thread ao encontrar o <code>await</code>, devolvendo-a ao pool.</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // Ativar logs para debug
  const DEBUG = true;
  console.log = DEBUG ? console.log.bind(console) : function(){};
  
  // Armazenar timeouts ativos para manipula√ß√£o de pause/resume
  const activeTimeouts = {
    sync: [],
    async: []
  };
  
  // Fun√ß√£o para adicionar eventos √† lista
  function addEvent(type, message, category = '') {
    // Limitar a 10 eventos mais recentes
    const eventList = document.getElementById(`${type}-events`);
    if (!eventList) return;
    
    // Criar novo item de evento
    const eventItem = document.createElement('li');
    
    // Adicionar timestamp
    const now = new Date();
    const timestamp = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
    
    eventItem.textContent = `${timestamp} - ${message}`;
    
    // Adicionar classe para estilo
    if (category) {
      eventItem.classList.add(`event-${category}`);
    }
    
    // Adicionar ao in√≠cio da lista (mais recente primeiro)
    eventList.insertBefore(eventItem, eventList.firstChild);
    
    // Manter apenas os 10 mais recentes
    while (eventList.children.length > 10) {
      eventList.removeChild(eventList.lastChild);
    }
    
    // Log no console tamb√©m
    console.log(`[${type.toUpperCase()}] ${message}`);
  }

  // Estado global de anima√ß√£o
  const animation = {
    globalStartTime: 0,
    globalTimerIntervalId: null,
    globalTotalPauseTime: 0,
    globalPauseStartTime: 0,
    sync: {
      running: false,
      completed: 0,
      blocked: 0,
      available: 2,
      startTime: 0,
      pauseStartTime: 0,
      totalPauseTime: 0,
      intervalId: null,
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: [],
      totalRequests: 0
    },
    async: {
      running: false,
      completed: 0,
      available: 2,
      blocked: 0,
      startTime: 0,
      pauseStartTime: 0,
      totalPauseTime: 0,
      intervalId: null, 
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: [],
      totalRequests: 0
    }
  };

  // Selecionar elementos DOM
  const elements = {
    syncDiagram: document.getElementById('sync-diagram'),
    asyncDiagram: document.getElementById('async-diagram'),
    syncCompleted: document.getElementById('sync-completed'),
    asyncCompleted: document.getElementById('async-completed'),
    syncBlocked: document.getElementById('sync-blocked'),
    syncAvailable: document.getElementById('sync-available'),
    asyncBlocked: document.getElementById('async-blocked'),
    asyncAvailable: document.getElementById('async-available'),
    playBoth: document.getElementById('play-both'),
    pauseBoth: document.getElementById('pause-both'),
    resetBoth: document.getElementById('reset-both'),
    globalTimer: document.getElementById('global-timer'),
    syncRequestsPerSecond: document.getElementById('sync-requests-per-second'),
    asyncRequestsPerSecond: document.getElementById('async-requests-per-second')
  };

  // Event listeners para os controles centrais
  document.getElementById('play-both').addEventListener('click', startBothAnimations);
  document.getElementById('pause-both').addEventListener('click', pauseBothAnimations);
  document.getElementById('reset-both').addEventListener('click', resetBothAnimations);

  // Fun√ß√£o utilit√°ria para criar uma setinha (requisi√ß√£o)
  function createArrow(diagram, x, y, text, color) {
    const arrow = document.createElement('div');
    arrow.className = 'arrow';
    arrow.textContent = text || '=>';
    arrow.style.left = x + 'px';
    arrow.style.top = y + 'px';
    if (color) arrow.style.color = color;
    diagram.appendChild(arrow);
    return arrow;
  }

  // Timeout vers√£o aprimorada que gerencia pausas
  function createTimeout(callback, delay, type) {
    if (animation[type].isPaused) {
      // Se j√° estiver pausado, apenas registra para retomar depois
      const timeoutObj = { callback, delay, remaining: delay };
      activeTimeouts[type].push(timeoutObj);
      return timeoutObj;
    }
    
    const start = Date.now();
    const timeoutObj = {
      id: setTimeout(function() {
        // Remover da lista de timeouts ativos
        const index = activeTimeouts[type].indexOf(timeoutObj);
        if (index > -1) {
          activeTimeouts[type].splice(index, 1);
        }
        callback();
      }, delay),
      callback,
      delay,
      start,
      remaining: delay
    };
    
    activeTimeouts[type].push(timeoutObj);
    return timeoutObj;
  }
  
  // Pausar todos os timeouts ativos
  function pauseAllTimeouts(type) {
    activeTimeouts[type].forEach(timeoutObj => {
      clearTimeout(timeoutObj.id);
      timeoutObj.remaining = timeoutObj.delay - (Date.now() - timeoutObj.start);
      if (timeoutObj.remaining < 0) timeoutObj.remaining = 0;
    });
  }
  
  // Retomar todos os timeouts pausados
  function resumeAllTimeouts(type) {
    activeTimeouts[type].forEach(timeoutObj => {
      timeoutObj.id = setTimeout(function() {
        // Remover da lista de timeouts ativos
        const index = activeTimeouts[type].indexOf(timeoutObj);
        if (index > -1) {
          activeTimeouts[type].splice(index, 1);
        }
        timeoutObj.callback();
      }, timeoutObj.remaining);
      timeoutObj.start = Date.now();
    });
  }

  // Move "elem" de (x1, y1) para (x2, y2) em 'duration' ms
  function moveElement(elem, x1, y1, x2, y2, duration, callback, type) {
    if (!elem || !document.body.contains(elem)) return;
    
    const steps = 40;
    let step = 0;
    const interval = duration / steps;
    const dx = (x2 - x1) / steps;
    const dy = (y2 - y1) / steps;

    // Incrementar contador de anima√ß√µes em andamento
    if (type) {
      animation[type].animationsInProgress++;
    }

    // Se estiver pausado, salvar para retomar depois
    if (type && animation[type].isPaused) {
      const pausedAnimation = {
        elem, x1, y1, x2, y2, duration, callback, type,
        currentX: x1, currentY: y1, step: 0
      };
      animation[type].pausedAnimations.push(pausedAnimation);
      return;
    }

    let animId;
    const anim = () => {
      // Verificar se o elemento ainda existe
      if (!elem || !document.body.contains(elem)) {
        cancelAnimationFrame(animId);
        if (type) {
          animation[type].animationsInProgress--;
        }
        return;
      }
      
      // Se estiver pausado, interromper
      if (type && animation[type].isPaused) {
        cancelAnimationFrame(animId);
        const pausedAnimation = {
          elem, x1, y1, x2, y2, duration, callback, type,
          currentX: elem.style.left.replace('px', '') || x1,
          currentY: elem.style.top.replace('px', '') || y1,
          step
        };
        animation[type].pausedAnimations.push(pausedAnimation);
        return;
      }

      step++;
      const nx = x1 + dx * step;
      const ny = y1 + dy * step;
      elem.style.left = nx + 'px';
      elem.style.top = ny + 'px';
      if (step >= steps) {
        cancelAnimationFrame(animId);
        // Decrementar contador de anima√ß√µes em andamento
        if (type) {
          animation[type].animationsInProgress--;
        }
        if (callback) callback();
        return;
      }
      
      animId = requestAnimationFrame(anim);
    };
    
    animId = requestAnimationFrame(anim);
  }

  // Limpa as setas antigas e reseta o estado
  function clearArrows(diagram) {
    if (!diagram) return;
    
    // Remover setas
    const oldArrows = diagram.querySelectorAll('.arrow');
    oldArrows.forEach(a => a.remove());
    
    // Reset any waiting indicators
    const clients = diagram.querySelectorAll('.client-box');
    clients.forEach(c => c.classList.remove('waiting'));
    
    // Reset thread status
    const threads = diagram.querySelectorAll('.thread-box');
    threads.forEach(t => t.classList.remove('thread-blocked'));
  }
  
  // Helper to get thread positions
  function getThreadPosition(diagram, threadNumber) {
    if (!diagram) return null;
    
    const threads = diagram.querySelectorAll('.thread-box');
    if (threadNumber <= threads.length) {
      const thread = threads[threadNumber - 1];
      const rect = thread.getBoundingClientRect();
      const diagramRect = diagram.getBoundingClientRect();
      return {
        x: parseInt(thread.style.left) || (rect.left - diagramRect.left + 10),
        y: parseInt(thread.style.top) || (rect.top - diagramRect.top + 15)
      };
    }
    return null;
  }

  // Atualizar contadores
  function updateCounters(type) {
    if (type === 'sync') {
      elements.syncCompleted.textContent = animation.sync.completed;
      elements.syncBlocked.textContent = animation.sync.blocked;
      elements.syncAvailable.textContent = animation.sync.available;
    } else {
      elements.asyncCompleted.textContent = animation.async.completed;
      elements.asyncAvailable.textContent = animation.async.available;
      elements.asyncBlocked.textContent = animation.async.blocked;
    }
  }

  // Iniciar anima√ß√£o
  function startAnimation(type) {
    if (animation[type].running && !animation[type].isPaused) return;
    
    // Se estiver pausado, resumir
    if (animation[type].isPaused) {
      resumeAnimation(type);
      return;
    }
    
    // Resetar primeiro (mas manter o contador se j√° estava em execu√ß√£o)
    const wasRunningBefore = animation[type].running;
    resetAnimation(type);
    
    // Configurar estado
    animation[type].running = true;
    animation[type].startTime = Date.now();
    animation[type].totalPauseTime = 0;
    
    addEvent(type, `Iniciando anima√ß√£o ${type === 'sync' ? 's√≠ncrona' : 'ass√≠ncrona'}`, 'thread');
    
    // Adicionar mensagem de status de contagem
    const statusIndicator = document.querySelector(`#${type}-diagram .status-indicator`);
    if (statusIndicator && animation[type].completed > 0) {
      addEvent(type, `Contagem total: ${animation[type].completed} requisi√ß√µes processadas`, 'complete');
    }
    
    // Iniciar fluxo apropriado
    if (type === 'sync') {
      startSync();
    } else {
      startAsync();
    }
  }
  
  // Pausar anima√ß√£o
  function pauseAnimation(type) {
    if (!animation[type].running || animation[type].isPaused) return;
    
    // Gravar o tempo de in√≠cio da pausa
    animation[type].isPaused = true;
    animation[type].pauseStartTime = Date.now();
    
    // Pausar todos os timeouts
    pauseAllTimeouts(type);
    
    addEvent(type, `Anima√ß√£o pausada`, 'thread');
    console.log(`[${type.toUpperCase()}] Animation paused at ${animation[type].pauseStartTime}`);
  }
  
  // Pausar ambas anima√ß√µes
  function pauseBothAnimations() {
    pauseAnimation('sync');
    pauseAnimation('async');
    
    // Pausar timer global
    animation.globalPauseStartTime = Date.now();
    
    elements.pauseBoth.disabled = true;
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Continuar';
  }
  
  // Resumir anima√ß√£o
  function resumeAnimation(type) {
    if (!animation[type].running || !animation[type].isPaused) return;
    
    // Calcular o tempo total de pausa
    const pauseDuration = Date.now() - animation[type].pauseStartTime;
    animation[type].totalPauseTime += pauseDuration;
    
    // Desmarcar pausa
    animation[type].isPaused = false;
    
    addEvent(type, `Anima√ß√£o retomada`, 'thread');
    console.log(`[${type.toUpperCase()}] Animation resumed. Pause duration: ${pauseDuration}ms, Total pause: ${animation[type].totalPauseTime}ms`);
    
    // Retomar timeouts
    resumeAllTimeouts(type);
    
    // Retomar anima√ß√µes pausadas
    const pausedAnimations = [...animation[type].pausedAnimations];
    animation[type].pausedAnimations = [];
    
    pausedAnimations.forEach(anim => {
      moveElement(
        anim.elem, 
        parseFloat(anim.currentX), 
        parseFloat(anim.currentY), 
        anim.x2, 
        anim.y2, 
        anim.duration * (1 - anim.step / 40), 
        anim.callback,
        anim.type
      );
    });
  }
  
  // Resetar anima√ß√£o (sem resetar contadores entre ciclos)
  function resetAnimation(type) {
    console.log(`[${type.toUpperCase()}] Resetting animation`);
    
    // Parar qualquer anima√ß√£o em andamento
    clearInterval(animation[type].intervalId);
    
    // Limpar todos os timeouts ativos
    for (const timeoutObj of activeTimeouts[type]) {
      clearTimeout(timeoutObj.id);
    }
    activeTimeouts[type] = [];
    
    // Limpar setas
    clearArrows(document.getElementById(`${type}-diagram`));
    
    // Limpar a lista de eventos
    const eventList = document.getElementById(`${type}-events`);
    if (eventList) {
      while (eventList.firstChild) {
        eventList.removeChild(eventList.firstChild);
      }
    }
    
    // Resetar estado
    animation[type].running = false;
    animation[type].animationsInProgress = 0;
    animation[type].isPaused = false;
    animation[type].pausedAnimations = [];
    animation[type].totalPauseTime = 0;
    
    // Resetar threads (mas n√£o o contador de requisi√ß√µes)
    if (type === 'sync') {
      animation.sync.blocked = 0;
      animation.sync.available = 2;
    } else {
      animation.async.blocked = 0;
      animation.async.available = 2;
    }
    
    // Atualizar contadores
    updateCounters(type);
    
    // Resetar status
    const statusIndicator = document.querySelector(`#${type}-diagram .status-indicator`);
    if (statusIndicator) {
      statusIndicator.textContent = 'Pronto para iniciar';
      statusIndicator.style.fontWeight = '';
      statusIndicator.style.color = '';
      statusIndicator.style.fontSize = '';
      statusIndicator.style.backgroundColor = '';
      statusIndicator.style.border = '';
    }
  }
  
  // Fun√ß√£o para atualizar o timer global
  function updateGlobalTimer() {
    if (!animation.globalStartTime) return;
    
    // Se estiver pausado, n√£o atualizar o tempo
    if (animation.sync.isPaused || animation.async.isPaused) return;
    
    const elapsed = (Date.now() - animation.globalStartTime - animation.globalTotalPauseTime) / 1000;
    elements.globalTimer.textContent = `Tempo: ${Math.floor(elapsed)}s`;
  }
  
  // Iniciar ambas anima√ß√µes
  function startBothAnimations() {
    if (animation.sync.isPaused || animation.async.isPaused) {
      // Se estiver pausado, continuar
      resumeAnimation('sync');
      resumeAnimation('async');
      
      // Retomar timer global
      const pauseDuration = Date.now() - animation.globalPauseStartTime;
      animation.globalTotalPauseTime += pauseDuration;
      
      elements.playBoth.disabled = true;
      elements.pauseBoth.disabled = false;
      elements.playBoth.textContent = '‚ñ∂Ô∏è Iniciar Compara√ß√£o';
      return;
    }
    
    // Iniciar timer global
    animation.globalStartTime = Date.now();
    animation.globalTotalPauseTime = 0;
    animation.globalTimerIntervalId = setInterval(updateGlobalTimer, 100);
    
    startAnimation('sync');
    startAnimation('async');
    
    elements.playBoth.disabled = true;
    elements.pauseBoth.disabled = false;
  }
  
  // Resetar ambas anima√ß√µes (incluindo contadores de requisi√ß√µes)
  function resetBothAnimations() {
    // Primeiro resetamos a anima√ß√£o
    resetAnimation('sync');
    resetAnimation('async');
    
    // Parar e resetar timer global
    clearInterval(animation.globalTimerIntervalId);
    animation.globalStartTime = 0;
    animation.globalTotalPauseTime = 0;
    elements.globalTimer.textContent = 'Tempo: 0s';
    
    // Resetar contadores de requisi√ß√µes por segundo
    elements.syncRequestsPerSecond.textContent = '0';
    elements.asyncRequestsPerSecond.textContent = '0';
    
    // Agora tamb√©m resetamos os contadores de requisi√ß√µes completadas
    animation.sync.completed = 0;
    animation.async.completed = 0;
    animation.sync.totalRequests = 0;
    animation.async.totalRequests = 0;
    
    // Atualizar contadores na interface
    updateCounters('sync');
    updateCounters('async');
    
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Iniciar Compara√ß√£o';
    elements.pauseBoth.disabled = true;
  }

  /* ======================================
       FLUXO S√çNCRONO
     ====================================== */
  function startSync() {
    const diagram = elements.syncDiagram;
    clearArrows(diagram);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    statusIndicator.textContent = 'Iniciando requisi√ß√µes s√≠ncronas...';

    // Posi√ß√µes iniciais das setinhas (3 clientes)
    const requests = [
      { x: 50, y: 75, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 165, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 255, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    // Free threads pool - usando um objeto para manter consist√™ncia entre chamadas
    const threadPoolRef = { pool: [1, 2] };
    
    // Start requests with slight delays
    if (!animation.sync.isPaused) {
      createTimeout(() => startRequest(0), 200, 'sync');
      createTimeout(() => {
        if (!animation.sync.isPaused) startRequest(1);
      }, 800, 'sync');
      createTimeout(() => {
        if (!animation.sync.isPaused) startRequest(2);
      }, 1400, 'sync');
    }
    
    function startRequest(index) {
      if (!animation.sync.running) return;
      
      const request = requests[index];
      
      // Create arrow with id badge
      const arrow = createArrow(diagram, request.x, request.y, '=>', request.color);
      const requestBadge = document.createElement('div');
      requestBadge.className = 'request-id';
      requestBadge.style.backgroundColor = request.color;
      requestBadge.textContent = request.id;
      arrow.appendChild(requestBadge);
      
      addEvent('sync', `Req ${request.id} iniciada, threads: ${threadPoolRef.pool.length}`, 'request');
      
      // Check if a thread is available
      if (threadPoolRef.pool.length > 0) {
        // Get a thread from the pool
        const threadNumber = threadPoolRef.pool.shift();
        
        // Atualizar contadores
        animation.sync.blocked++;
        animation.sync.available = threadPoolRef.pool.length;
        updateCounters('sync');
        
        const threadPos = getThreadPosition(diagram, threadNumber);
        
        // Get the thread element
        const threadElements = diagram.querySelectorAll('.thread-box');
        const threadElem = threadElements[threadNumber - 1];
        
        // Client -> Thread
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
        moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
          if (!animation.sync.running) return;
          
          // Thread processing - mark thread as assigned
          statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id}`;
          addEvent('sync', `Thread ${threadNumber} processando req ${request.id}`, 'thread');
          
          // Thread -> DB (Thread is blocked during this operation)
          if (threadElem && document.body.contains(threadElem)) {
            threadElem.classList.add('thread-blocked'); // Mark thread as blocked
            addEvent('sync', `Thread ${threadNumber} bloqueada`, 'wait');
          }
          
          moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
            if (!animation.sync.running) return;
            
            // "Bloqueado" por 2s no DB
            statusIndicator.textContent = `Thread ${threadNumber} BLOQUEADA aguardando DB (SYNC, bloqueia thread)`;
            addEvent('sync', `Aguardando DB por 2s (Thread ${threadNumber} bloqueada)`, 'db');
            
            // Timeout para simular opera√ß√£o de I/O
            createTimeout(() => {
              if (!animation.sync.running) return;
              
              // Return DB -> Thread
              statusIndicator.textContent = `Banco de dados respondeu para requisi√ß√£o ${request.id}`;
              addEvent('sync', `DB respondeu para req ${request.id}`, 'db');
              if (arrow && document.body.contains(arrow)) {
                arrow.classList.add('return');
                moveElement(arrow, 350, threadPos.y, threadPos.x, threadPos.y, 700, () => {
                  if (!animation.sync.running) return;
                  
                  // Thread -> Client
                  statusIndicator.textContent = `Thread ${threadNumber} enviando resposta ao cliente (req. ${request.id})`;
                  moveElement(arrow, threadPos.x, threadPos.y, request.x, request.y, 700, () => {
                    if (!animation.sync.running) return;
                    
                    // Return thread to the pool
                    if (threadElem && document.body.contains(threadElem)) {
                      threadElem.classList.remove('thread-blocked'); // Unblock thread
                    }
                    threadPoolRef.pool.push(threadNumber);
                    
                    // Atualizar contadores
                    animation.sync.blocked--;
                    animation.sync.completed++;
                    animation.sync.available = threadPoolRef.pool.length;
                    updateCounters('sync');
                    
                    addEvent('sync', `Req ${request.id} completa, thread ${threadNumber} liberada`, 'complete');
                    
                    statusIndicator.textContent = `Thread ${threadNumber} liberada, voltou para o pool`;
                    
                    // Check if there are waiting clients and process them
                    const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                    if (waitingClients.length > 0) {
                      waitingClients[0].classList.remove('waiting');
                      const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                      const waitingIndex = requests.findIndex(r => r.id === waitingId);
                      
                      console.log(`[SYNC] Starting waiting request ${waitingId}`);
                      
                      // Start waiting request after a small delay
                      createTimeout(() => startRequest(waitingIndex), 300, 'sync');
                    }
                    
                    // Continuar processamento em loop - iniciar nova rodada imediatamente
                    // Iniciar imediatamente novas requisi√ß√µes se todas da rodada atual terminaram
                    if (animation.sync.completed % 3 === 0 && animation.sync.animationsInProgress === 0) {
                      // Iniciar novo ciclo sem demora para maximizar processamento
                      if (!animation.sync.isPaused) {
                        statusIndicator.textContent = 'Iniciando novo ciclo...';
                        statusIndicator.style.fontWeight = '';
                        statusIndicator.style.color = '';
                        statusIndicator.style.fontSize = '';
                        statusIndicator.style.backgroundColor = '';
                        statusIndicator.style.border = '';
                        
                        // Limpar setas e estados, mas manter contadores
                        clearArrows(diagram);
                        
                        // Iniciar requisi√ß√µes para ciclo cont√≠nuo
                        const requests = [
                          { x: 50, y: 75, color: '#d9534f', clientIndex: 0, id: 1 },
                          { x: 50, y: 165, color: '#5bc0de', clientIndex: 1, id: 2 },
                          { x: 50, y: 255, color: '#5cb85c', clientIndex: 2, id: 3 }
                        ];
                        
                        // Iniciar novas requisi√ß√µes em paralelo (sem esperar)
                        startRequest(0);
                        createTimeout(() => startRequest(1), 100, 'sync');
                        createTimeout(() => startRequest(2), 200, 'sync');
                      }
                    }
                  }, 'sync');
                }, 'sync');
              }
            }, 2000, 'sync');
          }, 'sync');
        }, 'sync');
      } else {
        // No thread available, make the client "wait"
        const clients = diagram.querySelectorAll('.client-box');
        clients[request.clientIndex].classList.add('waiting');
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel (pool esgotado)`;
        addEvent('sync', `Req ${request.id} espera por thread (pool vazio)`, 'wait');
      }
    }
  }

  /* ======================================
       FLUXO ASS√çNCRONO
     ====================================== */
  function startAsync() {
    const diagram = elements.asyncDiagram;
    clearArrows(diagram);
    
    const statusIndicator = diagram.querySelector('.status-indicator');
    statusIndicator.textContent = 'Iniciando requisi√ß√µes ass√≠ncronas...';

    const requests = [
      { x: 50, y: 65, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 145, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 225, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    // Free threads pool - usando um objeto para manter consist√™ncia entre chamadas
    const threadPoolRef = { pool: [1, 2] };
    
    // Track pending I/O operations for visualization
    const pendingDbOperationsRef = { operations: [] };
    
    // Start requests with slight delays - same timing as sync for comparison
    if (!animation.async.isPaused) {
      createTimeout(() => startRequest(0), 200, 'async');
      createTimeout(() => {
        if (!animation.async.isPaused) startRequest(1);
      }, 800, 'async');
      createTimeout(() => {
        if (!animation.async.isPaused) startRequest(2);
      }, 1400, 'async');
    }
    
    function startRequest(index) {
      if (!animation.async.running) return;
      
      const request = requests[index];
      
      // Create arrow with id badge
      const arrow = createArrow(diagram, request.x, request.y, '=>', request.color);
      const requestBadge = document.createElement('div');
      requestBadge.className = 'request-id';
      requestBadge.style.backgroundColor = request.color;
      requestBadge.textContent = request.id;
      arrow.appendChild(requestBadge);
      
      addEvent('async', `Req ${request.id} iniciada, threads: ${threadPoolRef.pool.length}`, 'request');
      
      // Check if a thread is available
      if (threadPoolRef.pool.length > 0) {
        // Get a thread from the pool
        const threadNumber = threadPoolRef.pool.shift();
        
        // Atualizar contadores
        animation.async.blocked++;
        animation.async.available = threadPoolRef.pool.length;
        updateCounters('async');
        
        const threadPos = getThreadPosition(diagram, threadNumber);
        
        // Get the thread element
        const threadElements = diagram.querySelectorAll('.thread-box');
        const threadElem = threadElements[threadNumber - 1];
        
        // Client -> Thread
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
        moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
          if (!animation.async.running) return;
          
          // Thread processing - brief CPU work
          statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id} (setup)`;
          addEvent('async', `Thread ${threadNumber} processando req ${request.id}`, 'thread');
          
          // Quick thread work (async setup)
          createTimeout(() => {
            if (!animation.async.running) return;
            
            // *** Thread is released here (await) - KEY DIFFERENCE ***
            statusIndicator.textContent = `Thread ${threadNumber} encontrou await, RETORNANDO AO POOL (ASYNC)`;
            
            // Return thread to the pool immediately
            threadPoolRef.pool.push(threadNumber);
            
            // Atualizar contadores
            animation.async.blocked--;
            animation.async.available = threadPoolRef.pool.length;
            updateCounters('async');
            
            addEvent('async', `Thread ${threadNumber} liberada no await`, 'thread');
            
            // Check if there are waiting clients and process them
            const waitingClients = diagram.querySelectorAll('.client-box.waiting');
            if (waitingClients.length > 0) {
              waitingClients[0].classList.remove('waiting');
              const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
              const waitingIndex = requests.findIndex(r => r.id === waitingId);
              
              statusIndicator.textContent = `Thread ${threadNumber} dispon√≠vel para requisi√ß√£o ${waitingId}`;
              console.log(`[ASYNC] Starting waiting request ${waitingId} with newly available thread`);
              
              // Start waiting request after a small delay
              createTimeout(() => startRequest(waitingIndex), 300, 'async');
            }
            
            // Arrow continues to DB without blocking thread
            statusIndicator.textContent = `Requisi√ß√£o ${request.id} continua para o DB (sem thread bloqueado)`;
            moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
              if (!animation.async.running) return;
              
              // Add to pending DB operations
              pendingDbOperationsRef.operations.push(request.id);
              
              // I/O operation in DB
              statusIndicator.textContent = `Requisi√ß√£o ${request.id} executando no banco de dados (I/O ass√≠ncrono)`;
              addEvent('async', `Req ${request.id} executando no DB por 2s`, 'db');
              
              // Timeout para simular opera√ß√£o de I/O - same time as sync for comparison
              createTimeout(() => {
                if (!animation.async.running) return;
                
                // Remove from pending operations
                pendingDbOperationsRef.operations = pendingDbOperationsRef.operations.filter(id => id !== request.id);
                
                // Get thread for completion (might be different thread)
                if (threadPoolRef.pool.length === 0) {
                  statusIndicator.textContent = `Requisi√ß√£o ${request.id} aguardando thread dispon√≠vel (opera√ß√£o I/O completou)`;
                  
                  // We'll check periodically if a thread becomes available
                  const checkInterval = setInterval(() => {
                    if (!animation.async.running) {
                      clearInterval(checkInterval);
                      return;
                    }
                    
                    if (threadPoolRef.pool.length > 0) {
                      clearInterval(checkInterval);
                      continueAfterDb();
                    }
                  }, 300);
                } else {
                  continueAfterDb();
                }
                
                function continueAfterDb() {
                  if (!animation.async.running) return;
                  
                  const returnThreadNumber = threadPoolRef.pool.shift();
                  
                  // Atualizar contadores
                  animation.async.blocked++;
                  animation.async.available = threadPoolRef.pool.length;
                  updateCounters('async');
                  
                  const returnThreadPos = getThreadPosition(diagram, returnThreadNumber);
                  const returnThreadElements = diagram.querySelectorAll('.thread-box');
                  const returnThreadElem = returnThreadElements[returnThreadNumber - 1];
                  
                  // Response DB -> Thread
                  statusIndicator.textContent = `Banco respondeu! Req. ${request.id} obt√©m Thread ${returnThreadNumber} (pode ser diferente)`;
                  addEvent('async', `DB respondeu para req ${request.id}`, 'db');
                  
                  if (arrow && document.body.contains(arrow)) {
                    arrow.classList.add('return');
                    moveElement(arrow, 350, threadPos.y, returnThreadPos.x, returnThreadPos.y, 700, () => {
                      if (!animation.async.running) return;
                      
                      // Quick completion work
                      statusIndicator.textContent = `Thread ${returnThreadNumber} finalizando requisi√ß√£o ${request.id} (p√≥s-await)`;
                      
                      createTimeout(() => {
                        if (!animation.async.running) return;
                        
                        // Thread -> Client
                        statusIndicator.textContent = `Thread ${returnThreadNumber} enviando resposta (req. ${request.id})`;
                        
                        moveElement(arrow, returnThreadPos.x, returnThreadPos.y, request.x, request.y, 700, () => {
                          if (!animation.async.running) return;
                          
                          // Return thread to pool
                          threadPoolRef.pool.push(returnThreadNumber);
                          
                          // Atualizar contadores
                          animation.async.blocked--;
                          animation.async.completed++;
                          animation.async.available = threadPoolRef.pool.length;
                          updateCounters('async');
                          
                          addEvent('async', `Req ${request.id} completa, thread ${returnThreadNumber} liberada`, 'complete');
                          
                          statusIndicator.textContent = `Thread ${returnThreadNumber} liberada, voltou para o pool`;
                          
                          // Check again for waiting clients
                          const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                          if (waitingClients.length > 0) {
                            waitingClients[0].classList.remove('waiting');
                            const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                            const waitingIndex = requests.findIndex(r => r.id === waitingId);
                            
                            console.log(`[ASYNC] Starting waiting request ${waitingId}`);
                            
                            // Start waiting request after a small delay
                            createTimeout(() => startRequest(waitingIndex), 300, 'async');
                          }
                          
                          // Continuar processamento em loop - iniciar nova rodada imediatamente
                          // Iniciar imediatamente novas requisi√ß√µes se todas da rodada atual terminaram
                          if (animation.async.completed % 3 === 0 && animation.async.animationsInProgress === 0) {
                            // Iniciar novo ciclo sem demora para maximizar processamento
                            if (!animation.async.isPaused) {
                              statusIndicator.textContent = 'Iniciando novo ciclo...';
                              statusIndicator.style.fontWeight = '';
                              statusIndicator.style.color = '';
                              statusIndicator.style.fontSize = '';
                              statusIndicator.style.backgroundColor = '';
                              statusIndicator.style.border = '';
                              
                              // Limpar setas e estados, mas manter contadores
                              clearArrows(diagram);
                              
                              // Iniciar requisi√ß√µes para ciclo cont√≠nuo
                              const requests = [
                                { x: 50, y: 65, color: '#d9534f', clientIndex: 0, id: 1 },
                                { x: 50, y: 145, color: '#5bc0de', clientIndex: 1, id: 2 },
                                { x: 50, y: 225, color: '#5cb85c', clientIndex: 2, id: 3 }
                              ];
                              
                              // Iniciar novas requisi√ß√µes em paralelo (sem esperar)
                              startRequest(0);
                              createTimeout(() => startRequest(1), 100, 'async');
                              createTimeout(() => startRequest(2), 200, 'async');
                            }
                          }
                        }, 'async');
                      }, 300, 'async');
                    }, 'async');
                  }
                }
              }, 2000, 'async');
            }, 'async');
          }, 500, 'async');
        }, 'async');
      } else {
        // No thread available, make the client "wait"
        const clients = diagram.querySelectorAll('.client-box');
        clients[request.clientIndex].classList.add('waiting');
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel (pool esgotado)`;
        addEvent('async', `Req ${request.id} espera por thread (pool vazio)`, 'wait');
      }
    }
  }
</script>

</body>
</html>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Exemplo Did√°tico - Sync vs. Async</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      margin: 20px;
    }
    h1 {
      text-align: center;
      margin-bottom: 10px;
    }
    .info {
      max-width: 900px;
      margin: 0 auto;
      background: #fff;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .diagram-container {
      display: flex;
      justify-content: center;
      flex-wrap: nowrap;
      max-width: 1200px;
      margin: 0 auto;
      position: relative;
    }
    
    @media (max-width: 960px) {
      .diagram-container {
        flex-direction: column;
        align-items: center;
      }
    }
    .section {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 5px;
      width: 460px;
      margin: 0 5px;
      padding: 10px;
      position: relative;
    }
    .section h2 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 10px;
    }
    .diagram {
      position: relative;
      width: 440px;
      height: 320px;
      border: 1px dashed #ccc;
      margin: 0 auto;
      overflow: hidden;
      background: #f9f9f9;
    }
    
    /* BOUNDARIES - dotted boxes to represent process limits */
    .client-process {
      width: 110px;
      height: 270px;
      border: 2px dotted #6c757d;
      border-radius: 8px;
      background: rgba(108, 117, 125, 0.05);
      position: absolute;
      left: 10px;
      top: 25px;
    }
    .client-process-label {
      position: absolute;
      top: 5px;
      left: 20px;
      font-size: 12px;
      font-weight: bold;
      color: #6c757d;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* SERVER PROCESS - middle */
    .server-process {
      width: 160px;
      height: 270px;
      border: 2px dotted #5bc0de;
      border-radius: 8px;
      background: rgba(91, 192, 222, 0.05);
      position: absolute;
      left: 140px;
      top: 25px;
    }
    .server-process-label {
      position: absolute;
      top: 5px;
      left: 180px;
      font-size: 12px;
      font-weight: bold;
      color: #5bc0de;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* DATABASE PROCESS - right side */
    .db-process {
      width: 90px;
      height: 120px;
      border: 2px dotted #f0ad4e;
      border-radius: 8px;
      background: rgba(240, 173, 78, 0.05);
      position: absolute;
      left: 320px;
      top: 100px;
    }
    .db-process-label {
      position: absolute;
      top: 80px;
      left: 335px;
      font-size: 12px;
      font-weight: bold;
      color: #f0ad4e;
      background: #f9f9f9;
      padding: 0 5px;
    }

    /* CLIENTES (3) - quadradinhos √† esquerda */
    .client-box {
      width: 90px; 
      height: 40px;
      background: #cfe2ff;  /* azul claro */
      border: 2px solid #6ea8fe; 
      border-radius: 5px;
      color: #333;
      text-align: center;
      line-height: 40px;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
      position: relative;
    }
    .client-box::before {
      content: "üåê";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 16px;
    }

    /* THREAD POOL (ret√¢ngulo grande com leve destaque) */
    .thread-pool {
      width: 120px;
      height: 160px;
      border: 2px dashed #5cb85c;
      border-radius: 5px;
      background: #f0fff0;
      position: absolute;
      left: 160px;
      top: 80px;
      z-index: 1;
    }
    .thread-pool-label {
      position: absolute;
      width: 120px;
      text-align: center;
      font-weight: bold;
      color: #5cb85c;
      left: 160px;
      top: 60px;
      font-size: 14px;
      z-index: 2;
    }

    /* THREADS dentro do pool (ret√¢ngulos) */
    .thread-box {
      width: 100px; 
      height: 35px;
      border: 2px solid #5cb85c; 
      background: #e3f9e3;
      border-radius: 5px;
      text-align: center;
      line-height: 35px;
      color: #333;
      position: absolute;
      font-weight: bold;
      font-size: 13px;
      z-index: 2;
      position: relative;
    }
    .thread-box::before {
      content: "‚öôÔ∏è";
      position: absolute;
      left: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }
    
    /* Thread bloqueada */
    .thread-blocked {
      background: #ffcccc !important;
      border-color: #dc3545 !important;
      color: #dc3545;
    }
    .thread-blocked::after {
      content: "üîí";
      position: absolute;
      right: 5px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
    }

    /* BANCO DE DADOS (ret√¢ngulo/cilindro estilizado) */
    .database {
      width: 60px;
      height: 80px;
      border: 2px solid #f0ad4e;
      border-radius: 5px;
      background: #fdf6ea; /* Amarelinho */
      color: #f0ad4e;
      text-align: center;
      line-height: 80px;
      font-weight: bold;
      position: absolute;
      left: 335px;
      top: 130px;
      z-index: 2;
    }

    /* SETAS (requisi√ß√µes) - vamos usar divs pequenas com texto "=>" para simbolizar setinhas em movimento */
    .arrow {
      position: absolute;
      font-size: 22px;
      font-weight: bold;
      user-select: none;
      pointer-events: none;
      z-index: 3;
      background: rgba(255, 255, 255, 0.7);
      padding: 0 3px;
      border-radius: 3px;
    }
    /* Setas que est√£o "voltando" (vermelho, p.ex.) */
    .arrow.return {
      color: #d9534f;
    }
    
    /* Request ID badge */
    .request-id {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      color: white;
      text-align: center;
      line-height: 18px;
      font-size: 12px;
      font-weight: bold;
      margin-top: -10px;
      margin-left: 15px;
    }

    /* Visual indicator for request in queue */
    .waiting {
      border: 2px dashed #d9534f !important;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }

    /* Estado das opera√ß√µes */
    .status-indicator {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      height: 25px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 3px;
      text-align: center;
      line-height: 25px;
      font-weight: bold;
      font-size: 12px;
      color: #666;
    }
    
    /* Contador de requisi√ß√µes */
    .metrics {
      margin-top: 10px;
      display: flex;
      justify-content: space-around;
      padding: 5px;
      border-top: 1px solid #eee;
    }
    .counter {
      text-align: center;
      font-weight: bold;
      font-size: 14px;
    }
    .counter span {
      display: inline-block;
      padding: 3px 8px;
      background: #f0f0f0;
      border-radius: 3px;
      min-width: 30px;
    }
    
    /* Bot√µes unificados ao centro */
    .central-controls {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      background: white;
      padding: 15px;
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-width: 140px;
      border: 1px solid #ddd;
    }
    
    .central-controls button {
      margin: 5px 0;
      width: 120px;
    }
    
    .central-controls .timer-display {
      margin-top: 10px;
      text-align: center;
      font-size: 13px;
      font-weight: bold;
    }
    
    @media (max-width: 960px) {
      .central-controls {
        position: static;
        transform: none;
        margin: 10px auto;
        flex-direction: row;
        flex-wrap: wrap;
        width: 90%;
        max-width: 460px;
      }
      
      .central-controls button {
        margin: 5px;
      }
    }
    
    /* Bot√µes individuais (removidos) */
    .controls {
      display: none;
    }
    button {
      margin: 0 5px;
      padding: 8px 14px;
      border: 1px solid #ccc;
      background: #eee;
      border-radius: 3px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.2s ease;
    }
    button:hover {
      background: #ddd;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button.play-pause {
      min-width: 80px;
    }
    button.primary {
      background: #007bff;
      color: white;
      border-color: #0069d9;
    }
    button.primary:hover {
      background: #0069d9;
    }
    button.secondary {
      background: #6c757d;
      color: white;
      border-color: #5a6268;
    }
    button.secondary:hover {
      background: #5a6268;
    }
    
    .legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 15px;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      background: #fff;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 5px 15px;
      font-size: 14px;
    }
    .legend-color {
      width: 20px;
      height: 20px;
      margin-right: 8px;
      border-radius: 3px;
    }
    
    /* Temporizador */
    .timer {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      background: rgba(0,0,0,0.1);
      border-radius: 15px;
      font-size: 14px;
      font-weight: bold;
    }
  </style>
</head>
<body>

<h1>Fluxo S√≠ncrono vs. Ass√≠ncrono em ASP.NET Core</h1>

<div class="info">
  <strong>Cen√°rio:</strong> 2 threads no servidor processando 3 requisi√ß√µes simult√¢neas.
  <br><br>
  <strong>S√≠ncrono:</strong> Cada thread fica "presa" aguardando o banco de dados, n√£o liberando o 
  <em>Thread Pool</em> para outras requisi√ß√µes. A terceira requisi√ß√£o precisa aguardar at√© que uma thread seja liberada.
  <br>
  <strong>Ass√≠ncrono:</strong> Assim que a requisi√ß√£o inicia I/O no DB (com <code>await</code>), 
  a thread √© devolvida ao <em>Thread Pool</em> para tratar outra requisi√ß√£o, permitindo que todas as 3 requisi√ß√µes 
  sejam processadas mesmo com apenas 2 threads dispon√≠veis.
</div>



<div class="diagram-container">

  <!-- Se√ß√£o: S√çNCRONO -->
  <div class="section">
    <h2>S√≠ncrono</h2>
    <div class="diagram" id="sync-diagram">
      <!-- Boundaries -->
      <div class="client-process"></div>
      <div class="client-process-label">Processo Cliente</div>
      
      <div class="server-process"></div>
      <div class="server-process-label">Processo Servidor</div>
      
      <div class="db-process"></div>
      <div class="db-process-label">Banco de Dados</div>
      
      <!-- 3 Clients -->
      <div class="client-box" style="left:20px; top:50px;">Request 1</div>
      <div class="client-box" style="left:20px; top:140px;">Request 2</div>
      <div class="client-box" style="left:20px; top:230px;">Request 3</div>

      <!-- Thread Pool -->
      <div class="thread-pool"></div>
      <div class="thread-pool-label">Thread Pool (2)</div>

      <!-- 2 Threads dentro do pool -->
      <div class="thread-box" style="left:170px; top:100px;">Thread 1</div>
      <div class="thread-box" style="left:170px; top:180px;">Thread 2</div>

      <!-- DB √† direita -->
      <div class="database">DB</div>
      
      <!-- Timer -->
      <div class="timer" id="sync-timer">0.0s</div>
    </div>
    <div class="metrics">
      <div class="counter">Requisi√ß√µes Conclu√≠das: <span id="sync-completed">0</span>/3</div>
      <div class="counter">Threads Bloqueadas: <span id="sync-blocked">0</span>/2</div>
    </div>
  </div>
  
  <!-- Controles Centrais -->
  <div class="central-controls">
    <button id="play-both" class="primary">‚ñ∂Ô∏è Play</button>
    <button id="pause-both" class="secondary" disabled>‚è∏Ô∏è Pause</button>
    <button id="reset-both" class="secondary">üîÑ Reset</button>
    <div class="timer-display">
      <div id="sync-time" style="color: #dc3545;">Sinc: --</div>
      <div id="async-time" style="color: #28a745;">Async: --</div>
    </div>
  </div>

  <!-- Se√ß√£o: ASS√çNCRONO -->
  <div class="section">
    <h2>Ass√≠ncrono</h2>
    <div class="diagram" id="async-diagram">
      <!-- Boundaries -->
      <div class="client-process"></div>
      <div class="client-process-label">Processo Cliente</div>
      
      <div class="server-process"></div>
      <div class="server-process-label">Processo Servidor</div>
      
      <div class="db-process"></div>
      <div class="db-process-label">Banco de Dados</div>
      
      <!-- 3 Clients -->
      <div class="client-box" style="left:20px; top:50px;">Request 1</div>
      <div class="client-box" style="left:20px; top:140px;">Request 2</div>
      <div class="client-box" style="left:20px; top:230px;">Request 3</div>

      <!-- Thread Pool -->
      <div class="thread-pool"></div>
      <div class="thread-pool-label">Thread Pool (2)</div>

      <!-- 2 Threads dentro do pool -->
      <div class="thread-box" style="left:170px; top:100px;">Thread 1</div>
      <div class="thread-box" style="left:170px; top:180px;">Thread 2</div>

      <!-- DB √† direita -->
      <div class="database">DB</div>
      
      <!-- Timer -->
      <div class="timer" id="async-timer">0.0s</div>
    </div>
    <div class="metrics">
      <div class="counter">Requisi√ß√µes Conclu√≠das: <span id="async-completed">0</span>/3</div>
      <div class="counter">Threads Dispon√≠veis: <span id="async-available">2</span>/2</div>
    </div>
  </div>

</div>

<div class="legend">
  <div class="legend-item">
    <div class="legend-color" style="background: #cfe2ff; border: 2px solid #6ea8fe; position: relative;">
      <span style="position: absolute; left: 1px; top: -1px; font-size: 14px;">üåê</span>
    </div>
    <span>Requisi√ß√£o Web</span>
  </div>
  <div class="legend-item">
    <div class="legend-color" style="background: #e3f9e3; border: 2px solid #5cb85c; position: relative;">
      <span style="position: absolute; left: 1px; top: -1px; font-size: 12px;">‚öôÔ∏è</span>
    </div>
    <span>Thread Dispon√≠vel</span>
  </div>
  <div class="legend-item">
    <div class="legend-color" style="background: #ffcccc; border: 2px solid #dc3545; position: relative;">
      <span style="position: absolute; right: 1px; top: -1px; font-size: 12px;">üîí</span>
    </div>
    <span>Thread Bloqueada</span>
  </div>
  <div class="legend-item">
    <div class="legend-color" style="background: #f0fff0; border: 2px dashed #5cb85c;"></div>
    <span>Thread Pool</span>
  </div>
  <div class="legend-item">
    <div class="legend-color" style="background: #fdf6ea; border: 2px solid #f0ad4e;"></div>
    <span>Banco de Dados</span>
  </div>
</div>

<script>
  // Estado global de anima√ß√£o
  const animation = {
    sync: {
      running: false,
      completed: 0,
      blocked: 0,
      startTime: 0,
      endTime: 0,
      intervalId: null,
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: []
    },
    async: {
      running: false,
      completed: 0,
      available: 2,
      startTime: 0,
      endTime: 0,
      intervalId: null, 
      animationsInProgress: 0,
      isPaused: false,
      pausedAnimations: []
    }
  };

  // Selecionar elementos DOM
  const elements = {
    syncDiagram: document.getElementById('sync-diagram'),
    asyncDiagram: document.getElementById('async-diagram'),
    syncCompleted: document.getElementById('sync-completed'),
    asyncCompleted: document.getElementById('async-completed'),
    syncBlocked: document.getElementById('sync-blocked'),
    asyncAvailable: document.getElementById('async-available'),
    syncTimer: document.getElementById('sync-timer'),
    asyncTimer: document.getElementById('async-timer'),
    syncTime: document.getElementById('sync-time'),
    asyncTime: document.getElementById('async-time'),
    playBoth: document.getElementById('play-both'),
    pauseBoth: document.getElementById('pause-both'),
    resetBoth: document.getElementById('reset-both')
  };

  // Event listeners para os controles centrais
  document.getElementById('play-both').addEventListener('click', startBothAnimations);
  document.getElementById('pause-both').addEventListener('click', pauseBothAnimations);
  document.getElementById('reset-both').addEventListener('click', resetBothAnimations);

  // Fun√ß√£o utilit√°ria para criar uma setinha (requisi√ß√£o)
  function createArrow(diagramId, x, y, text, color) {
    const diagram = document.getElementById(diagramId);
    const arrow = document.createElement('div');
    arrow.className = 'arrow';
    arrow.textContent = text || '=>';
    arrow.style.left = x + 'px';
    arrow.style.top = y + 'px';
    if (color) arrow.style.color = color;
    diagram.appendChild(arrow);
    return arrow;
  }

  // Move "elem" de (x1, y1) para (x2, y2) em 'duration' ms
  function moveElement(elem, x1, y1, x2, y2, duration, callback, type) {
    const steps = 40;
    let step = 0;
    const interval = duration / steps;
    const dx = (x2 - x1) / steps;
    const dy = (y2 - y1) / steps;

    // Incrementar contador de anima√ß√µes em andamento
    if (type) {
      animation[type].animationsInProgress++;
    }

    // Se estiver pausado, salvar para retomar depois
    if (type && animation[type].isPaused) {
      const pausedAnimation = {
        elem, x1, y1, x2, y2, duration, callback, type,
        currentX: x1, currentY: y1, step: 0
      };
      animation[type].pausedAnimations.push(pausedAnimation);
      return;
    }

    const anim = setInterval(() => {
      // Se estiver pausado, interromper
      if (type && animation[type].isPaused) {
        clearInterval(anim);
        const pausedAnimation = {
          elem, x1, y1, x2, y2, duration, callback, type,
          currentX: elem.style.left.replace('px', ''),
          currentY: elem.style.top.replace('px', ''),
          step
        };
        animation[type].pausedAnimations.push(pausedAnimation);
        return;
      }

      step++;
      const nx = x1 + dx * step;
      const ny = y1 + dy * step;
      elem.style.left = nx + 'px';
      elem.style.top = ny + 'px';
      if (step >= steps) {
        clearInterval(anim);
        // Decrementar contador de anima√ß√µes em andamento
        if (type) {
          animation[type].animationsInProgress--;
        }
        if (callback) callback();
      }
    }, interval);
  }

  // Limpa as setas antigas e reseta o estado
  function clearArrows(diagramId) {
    const diag = document.getElementById(diagramId);
    
    // Remover setas
    const oldArrows = diag.querySelectorAll('.arrow');
    oldArrows.forEach(a => a.remove());
    
    // Reset any waiting indicators
    const clients = diag.querySelectorAll('.client-box');
    clients.forEach(c => c.classList.remove('waiting'));
    
    // Reset thread status
    const threads = diag.querySelectorAll('.thread-box');
    threads.forEach(t => t.classList.remove('thread-blocked'));
    
    // Remover indicador de status se existir
    const statusIndicator = diag.querySelector('.status-indicator');
    if (statusIndicator) {
      statusIndicator.remove();
    }
  }
  
  // Helper to get thread positions
  function getThreadPosition(diagId, threadNumber) {
    const diagram = document.getElementById(diagId);
    const threads = diagram.querySelectorAll('.thread-box');
    if (threadNumber <= threads.length) {
      const thread = threads[threadNumber - 1];
      const rect = thread.getBoundingClientRect();
      const diagramRect = diagram.getBoundingClientRect();
      return {
        x: parseInt(thread.style.left) || (rect.left - diagramRect.left + 10),
        y: parseInt(thread.style.top) || (rect.top - diagramRect.top + 15)
      };
    }
    return null;
  }

  // Atualizar contadores
  function updateCounters(type) {
    if (type === 'sync') {
      elements.syncCompleted.textContent = animation.sync.completed;
      elements.syncBlocked.textContent = animation.sync.blocked;
    } else {
      elements.asyncCompleted.textContent = animation.async.completed;
      elements.asyncAvailable.textContent = animation.async.available;
    }
  }

  // Atualizar timer
  function updateTimer(type) {
    if (!animation[type].running) return;
    
    const elapsed = (Date.now() - animation[type].startTime) / 1000;
    const timer = document.getElementById(`${type}-timer`);
    timer.textContent = `${elapsed.toFixed(1)}s`;
    
    // Se todas as requisi√ß√µes conclu√≠das e n√£o h√° mais anima√ß√µes em andamento, parar timer
    if (animation[type].completed === 3 && animation[type].animationsInProgress === 0) {
      clearInterval(animation[type].intervalId);
      animation[type].endTime = Date.now();
      const totalTime = ((animation[type].endTime - animation[type].startTime) / 1000).toFixed(1);
      document.getElementById(`${type}-time`).textContent = `${type === 'sync' ? 'S√≠ncrono' : 'Ass√≠ncrono'}: ${totalTime}s`;
    }
  }

  // Iniciar anima√ß√£o
  function startAnimation(type) {
    if (animation[type].running && !animation[type].isPaused) return;
    
    // Se estiver pausado, resumir
    if (animation[type].isPaused) {
      resumeAnimation(type);
      return;
    }
    
    // Resetar primeiro
    resetAnimation(type);
    
    // Configurar estado
    animation[type].running = true;
    animation[type].startTime = Date.now();
    animation[type].intervalId = setInterval(() => updateTimer(type), 100);
    
    // Iniciar fluxo apropriado
    if (type === 'sync') {
      startSync();
    } else {
      startAsync();
    }
  }
  
  // Pausar anima√ß√£o
  function pauseAnimation(type) {
    if (!animation[type].running) return;
    animation[type].isPaused = true;
  }
  
  // Pausar ambas anima√ß√µes
  function pauseBothAnimations() {
    pauseAnimation('sync');
    pauseAnimation('async');
    elements.pauseBoth.disabled = true;
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Continuar';
  }
  
  // Resumir anima√ß√£o
  function resumeAnimation(type) {
    if (!animation[type].running || !animation[type].isPaused) return;
    
    animation[type].isPaused = false;
    
    // Retomar anima√ß√µes pausadas
    const pausedAnimations = animation[type].pausedAnimations;
    while (pausedAnimations.length > 0) {
      const anim = pausedAnimations.pop();
      moveElement(
        anim.elem, 
        parseFloat(anim.currentX), 
        parseFloat(anim.currentY), 
        anim.x2, 
        anim.y2, 
        anim.duration * (1 - anim.step / 40), 
        anim.callback,
        anim.type
      );
    }
  }
  
  // Resetar anima√ß√£o
  function resetAnimation(type) {
    // Parar qualquer anima√ß√£o em andamento
    clearInterval(animation[type].intervalId);
    
    // Limpar setas
    clearArrows(`${type}-diagram`);
    
    // Resetar estado
    animation[type].running = false;
    animation[type].completed = 0;
    animation[type].animationsInProgress = 0;
    animation[type].isPaused = false;
    animation[type].pausedAnimations = [];
    
    if (type === 'sync') {
      animation.sync.blocked = 0;
    } else {
      animation.async.available = 2;
    }
    
    // Atualizar contadores
    updateCounters(type);
    
    // Resetar timer
    document.getElementById(`${type}-timer`).textContent = '0.0s';
  }
  
  // Iniciar ambas anima√ß√µes
  function startBothAnimations() {
    if (animation.sync.isPaused || animation.async.isPaused) {
      // Se estiver pausado, continuar
      resumeAnimation('sync');
      resumeAnimation('async');
      elements.playBoth.disabled = true;
      elements.pauseBoth.disabled = false;
      return;
    }
    
    startAnimation('sync');
    startAnimation('async');
    
    elements.playBoth.disabled = true;
    elements.pauseBoth.disabled = false;
  }
  
  // Resetar ambas anima√ß√µes
  function resetBothAnimations() {
    resetAnimation('sync');
    resetAnimation('async');
    elements.syncTime.textContent = 'Sinc: --';
    elements.asyncTime.textContent = 'Async: --';
    elements.playBoth.disabled = false;
    elements.playBoth.textContent = '‚ñ∂Ô∏è Play';
    elements.pauseBoth.disabled = true;
  }

  /* ======================================
       FLUXO S√çNCRONO
     ====================================== */
  function startSync() {
    const diagId = 'sync-diagram';
    clearArrows(diagId);
    
    // Add status indicator
    const diagram = document.getElementById(diagId);
    const statusIndicator = document.createElement('div');
    statusIndicator.className = 'status-indicator';
    statusIndicator.textContent = 'Iniciando requisi√ß√µes...';
    diagram.appendChild(statusIndicator);

    // Posi√ß√µes iniciais das setinhas (3 clientes)
    const requests = [
      { x: 50, y: 65, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 155, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 245, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    // Free threads pool
    const threadPool = [1, 2];
    
    // Start all requests almost simultaneously
    if (!animation.sync.isPaused) {
      startRequest(0);
      setTimeout(() => {
        if (!animation.sync.isPaused) startRequest(1);
      }, 300);
      setTimeout(() => {
        if (!animation.sync.isPaused) startRequest(2);
      }, 600);
    }
    
    function startRequest(index) {
      if (!animation.sync.running) return;
      
      const request = requests[index];
      
      // Create arrow with id badge
      const arrow = createArrow(diagId, request.x, request.y, '=>', request.color);
      const requestBadge = document.createElement('div');
      requestBadge.className = 'request-id';
      requestBadge.style.backgroundColor = request.color;
      requestBadge.textContent = request.id;
      arrow.appendChild(requestBadge);
      
      // Check if a thread is available
      if (threadPool.length > 0) {
        // Get a thread from the pool
        const threadNumber = threadPool.shift();
        const threadPos = getThreadPosition(diagId, threadNumber);
        
        // Get the thread element
        const threadElements = diagram.querySelectorAll('.thread-box');
        const threadElem = threadElements[threadNumber - 1];
        
        // Client -> Thread
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
        moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
          if (!animation.sync.running) return;
          
          // Thread processing - mark thread as assigned
          statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id}`;
          
          // Thread -> DB (Thread is blocked during this operation)
          threadElem.classList.add('thread-blocked'); // Mark thread as blocked
          animation.sync.blocked++;
          updateCounters('sync');
          
          moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
            if (!animation.sync.running) return;
            
            // "Bloqueado" por 3s no DB
            statusIndicator.textContent = `Thread ${threadNumber} BLOQUEADA aguardando DB (req. ${request.id})`;
            
            // Timeout para simular opera√ß√£o de I/O
            const dbTimeout = setTimeout(() => {
              if (!animation.sync.running) return;
              
              // Return DB -> Thread
              statusIndicator.textContent = `Banco de dados respondeu para requisi√ß√£o ${request.id}`;
              arrow.classList.add('return');
              moveElement(arrow, 350, threadPos.y, threadPos.x, threadPos.y, 700, () => {
                if (!animation.sync.running) return;
                
                // Thread -> Client
                statusIndicator.textContent = `Thread ${threadNumber} enviando resposta ao cliente (req. ${request.id})`;
                moveElement(arrow, threadPos.x, threadPos.y, request.x, request.y, 700, () => {
                  if (!animation.sync.running) return;
                  
                  // Return thread to the pool
                  threadElem.classList.remove('thread-blocked'); // Unblock thread
                  threadPool.push(threadNumber);
                  animation.sync.blocked--;
                  animation.sync.completed++;
                  updateCounters('sync');
                  
                  statusIndicator.textContent = `Thread ${threadNumber} liberada, voltou para o pool`;
                  
                  // Check if there are waiting clients and process them
                  const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                  if (waitingClients.length > 0) {
                    waitingClients[0].classList.remove('waiting');
                    const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                    const waitingIndex = requests.findIndex(r => r.id === waitingId);
                    startRequest(waitingIndex);
                  } else if (threadPool.length === 2) {
                    statusIndicator.textContent = 'Todas as requisi√ß√µes processadas';
                  }
                }, 'sync');
              }, 'sync');
            }, animation.sync.isPaused ? 0 : 2000);
            
            // Adicionar timeout √† lista de pausados
            if (animation.sync.isPaused) {
              animation.sync.pausedAnimations.push({
                isTimeout: true,
                timeoutId: dbTimeout
              });
            }
          }, 'sync');
        }, 'sync');
      } else {
        // No thread available, make the client "wait"
        const clients = diagram.querySelectorAll('.client-box');
        clients[request.clientIndex].classList.add('waiting');
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel`;
      }
    }
  }

  /* ======================================
       FLUXO ASS√çNCRONO
     ====================================== */
  function startAsync() {
    const diagId = 'async-diagram';
    clearArrows(diagId);
    
    // Add status indicator
    const diagram = document.getElementById(diagId);
    const statusIndicator = document.createElement('div');
    statusIndicator.className = 'status-indicator';
    statusIndicator.textContent = 'Iniciando requisi√ß√µes...';
    diagram.appendChild(statusIndicator);

    const requests = [
      { x: 50, y: 65, color: '#d9534f', clientIndex: 0, id: 1 },
      { x: 50, y: 155, color: '#5bc0de', clientIndex: 1, id: 2 },
      { x: 50, y: 245, color: '#5cb85c', clientIndex: 2, id: 3 }
    ];
    
    // Free threads pool
    const threadPool = [1, 2];
    
    // Start all requests almost simultaneously
    if (!animation.async.isPaused) {
      startRequest(0);
      setTimeout(() => {
        if (!animation.async.isPaused) startRequest(1);
      }, 300);
      setTimeout(() => {
        if (!animation.async.isPaused) startRequest(2);
      }, 600);
    }
    
    function startRequest(index) {
      if (!animation.async.running) return;
      
      const request = requests[index];
      
      // Create arrow with id badge
      const arrow = createArrow(diagId, request.x, request.y, '=>', request.color);
      const requestBadge = document.createElement('div');
      requestBadge.className = 'request-id';
      requestBadge.style.backgroundColor = request.color;
      requestBadge.textContent = request.id;
      arrow.appendChild(requestBadge);
      
      // Check if a thread is available
      if (threadPool.length > 0) {
        // Get a thread from the pool
        const threadNumber = threadPool.shift();
        animation.async.available = threadPool.length;
        updateCounters('async');
        
        const threadPos = getThreadPosition(diagId, threadNumber);
        
        // Get the thread element
        const threadElements = diagram.querySelectorAll('.thread-box');
        const threadElem = threadElements[threadNumber - 1];
        
        // Client -> Thread
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} chegando ao servidor`;
        moveElement(arrow, request.x, request.y, threadPos.x, threadPos.y, 700, () => {
          if (!animation.async.running) return;
          
          // Thread processing - brief CPU work
          statusIndicator.textContent = `Thread ${threadNumber} processando requisi√ß√£o ${request.id} (setup)`;
          
          // Quick thread work (async setup)
          setTimeout(() => {
            if (!animation.async.running) return;
            
            // *** Thread is released here (await) ***
            statusIndicator.textContent = `Thread ${threadNumber} encontrou await, retornando ao pool`;
            
            // Return thread to the pool immediately
            threadPool.push(threadNumber);
            animation.async.available = threadPool.length;
            updateCounters('async');
            
            // Check if there are waiting clients and process them
            const waitingClients = diagram.querySelectorAll('.client-box.waiting');
            if (waitingClients.length > 0) {
              waitingClients[0].classList.remove('waiting');
              const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
              const waitingIndex = requests.findIndex(r => r.id === waitingId);
              statusIndicator.textContent = `Thread ${threadNumber} dispon√≠vel para requisi√ß√£o ${waitingId}`;
              startRequest(waitingIndex);
            }
            
            // Arrow continues to DB without blocking thread
            statusIndicator.textContent = `Requisi√ß√£o ${request.id} continua para o DB (sem thread)`;
            moveElement(arrow, threadPos.x, threadPos.y, 350, threadPos.y, 700, () => {
              if (!animation.async.running) return;
              
              // I/O operation in DB (2s)
              statusIndicator.textContent = `Requisi√ß√£o ${request.id} executando no banco de dados`;
              
              // Timeout para simular opera√ß√£o de I/O
              const dbTimeout = setTimeout(() => {
                if (!animation.async.running) return;
                
                // Get thread for completion (might be different thread)
                if (threadPool.length === 0) {
                  statusIndicator.textContent = `Requisi√ß√£o ${request.id} aguardando thread dispon√≠vel`;
                  // We'll check periodically if a thread becomes available
                  const checkInterval = setInterval(() => {
                    if (!animation.async.running) {
                      clearInterval(checkInterval);
                      return;
                    }
                    
                    if (threadPool.length > 0) {
                      clearInterval(checkInterval);
                      continueAfterDb();
                    }
                  }, 300);
                } else {
                  continueAfterDb();
                }
                
                function continueAfterDb() {
                  if (!animation.async.running) return;
                  
                  const returnThreadNumber = threadPool.shift();
                  animation.async.available = threadPool.length;
                  updateCounters('async');
                  
                  const returnThreadPos = getThreadPosition(diagId, returnThreadNumber);
                  const returnThreadElem = threadElements[returnThreadNumber - 1];
                  
                  // Response DB -> Thread
                  statusIndicator.textContent = `Banco respondeu! Req. ${request.id} volta para Thread ${returnThreadNumber}`;
                  arrow.classList.add('return');
                  moveElement(arrow, 350, threadPos.y, returnThreadPos.x, returnThreadPos.y, 700, () => {
                    if (!animation.async.running) return;
                    
                    // Quick completion work
                    statusIndicator.textContent = `Thread ${returnThreadNumber} finalizando requisi√ß√£o ${request.id}`;
                    setTimeout(() => {
                      if (!animation.async.running) return;
                      
                      // Thread -> Client
                      statusIndicator.textContent = `Thread ${returnThreadNumber} enviando resposta (req. ${request.id})`;
                      moveElement(arrow, returnThreadPos.x, returnThreadPos.y, request.x, request.y, 700, () => {
                        if (!animation.async.running) return;
                        
                        // Return thread to pool
                        threadPool.push(returnThreadNumber);
                        animation.async.available = threadPool.length;
                        animation.async.completed++;
                        updateCounters('async');
                        
                        statusIndicator.textContent = `Thread ${returnThreadNumber} liberada, voltou para o pool`;
                        
                        // Check again for waiting clients
                        const waitingClients = diagram.querySelectorAll('.client-box.waiting');
                        if (waitingClients.length > 0) {
                          waitingClients[0].classList.remove('waiting');
                          const waitingId = parseInt(waitingClients[0].textContent.replace('Request ', ''));
                          const waitingIndex = requests.findIndex(r => r.id === waitingId);
                          startRequest(waitingIndex);
                        } else if (animation.async.completed === 3) {
                          statusIndicator.textContent = 'Todas as requisi√ß√µes processadas';
                        }
                      }, 'async');
                    }, animation.async.isPaused ? 0 : 300);
                  }, 'async');
                }
              }, animation.async.isPaused ? 0 : 2000);
              
              // Adicionar timeout √† lista de pausados
              if (animation.async.isPaused) {
                animation.async.pausedAnimations.push({
                  isTimeout: true,
                  timeoutId: dbTimeout
                });
              }
            }, 'async');
          }, animation.async.isPaused ? 0 : 500);
        }, 'async');
      } else {
        // No thread available, make the client "wait"
        const clients = diagram.querySelectorAll('.client-box');
        clients[request.clientIndex].classList.add('waiting');
        statusIndicator.textContent = `Requisi√ß√£o ${request.id} AGUARDANDO thread dispon√≠vel`;
      }
    }
  }
  
  // Inicializa√ß√£o
  document.addEventListener('DOMContentLoaded', function() {
    // Adicionar indicadores de status iniciais
    const syncDiag = document.getElementById('sync-diagram');
    const asyncDiag = document.getElementById('async-diagram');
    
    const syncStatus = document.createElement('div');
    syncStatus.className = 'status-indicator';
    syncStatus.textContent = 'Pronto para iniciar';
    syncDiag.appendChild(syncStatus);
    
    const asyncStatus = document.createElement('div');
    asyncStatus.className = 'status-indicator';
    asyncStatus.textContent = 'Pronto para iniciar';
    asyncDiag.appendChild(asyncStatus);
  });
</script>

</body>
</html>